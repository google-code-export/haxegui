<haxe>
	<enum path="flash.text.TextFormatAlign" params="" file="/usr/lib/haxe/std/flash9/text/TextFormatAlign.hx">
		<RIGHT/>
		<LEFT/>
		<JUSTIFY/>
		<CENTER/>
	</enum>
	<class path="flash.ui.Mouse" params="" file="/usr/lib/haxe/std/flash9/ui/Mouse.hx" extern="1">
		<hide public="1" static="1"><f a=""><e path="Void"/></f></hide>
		<show public="1" static="1"><f a=""><e path="Void"/></f></show>
	</class>
	<class path="haxe.Public" params="" file="/usr/lib/haxe/std/haxe/Public.hx" interface="1"><haxe_doc>
	When implementing this interface, all default fields access for the class and
	subclasses becomes [public] instead of [private].
</haxe_doc></class>
	<class path="feffects.easing.Circ" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Circ.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" line="5" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" line="10" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" line="15" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<enum path="flash.display.StageAlign" params="" file="/usr/lib/haxe/std/flash9/display/StageAlign.hx">
		<TOP_RIGHT/>
		<TOP_LEFT/>
		<TOP/>
		<RIGHT/>
		<LEFT/>
		<BOTTOM_RIGHT/>
		<BOTTOM_LEFT/>
		<BOTTOM/>
	</enum>
	<class path="flash.text.TextFormat" params="" file="/usr/lib/haxe/std/flash9/text/TextFormat.hx" extern="1">
		<align public="1"><e path="flash.text.TextFormatAlign"/></align>
		<blockIndent public="1"><d/></blockIndent>
		<bold public="1"><d/></bold>
		<bullet public="1"><d/></bullet>
		<color public="1"><d/></color>
		<display public="1"><e path="flash.text.TextFormatDisplay"/></display>
		<font public="1"><c path="String"/></font>
		<indent public="1"><d/></indent>
		<italic public="1"><d/></italic>
		<kerning public="1"><d/></kerning>
		<leading public="1"><d/></leading>
		<leftMargin public="1"><d/></leftMargin>
		<letterSpacing public="1"><d/></letterSpacing>
		<rightMargin public="1"><d/></rightMargin>
		<size public="1"><d/></size>
		<tabStops public="1"><c path="Array"><t path="UInt"/></c></tabStops>
		<target public="1"><c path="String"/></target>
		<underline public="1"><d/></underline>
		<url public="1"><c path="String"/></url>
		<new public="1"><f a="?font:?size:?color:?bold:?italic:?underline:?url:?target:?align:?leftMargin:?rightMargin:?indent:?leading">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
	<c path="String"/>
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.IEventDispatcher" params="" file="/usr/lib/haxe/std/flash9/events/IEventDispatcher.hx" extern="1" interface="1">
		<addEventListener public="1"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<willTrigger public="1"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
	</class>
	<class path="flash.events.EventDispatcher" params="" file="/usr/lib/haxe/std/flash9/events/EventDispatcher.hx" extern="1">
		<implements path="flash.events.IEventDispatcher"/>
		<addEventListener public="1"><f a="type:listener:?useCapture:?priority:?useWeakReference">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></addEventListener>
		<dispatchEvent public="1"><f a="event">
	<c path="flash.events.Event"/>
	<e path="Bool"/>
</f></dispatchEvent>
		<hasEventListener public="1"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></hasEventListener>
		<removeEventListener public="1"><f a="type:listener:?useCapture">
	<c path="String"/>
	<f a="">
		<d/>
		<e path="Void"/>
	</f>
	<e path="Bool"/>
	<e path="Void"/>
</f></removeEventListener>
		<toString public="1"><f a=""><c path="String"/></f></toString>
		<willTrigger public="1"><f a="type">
	<c path="String"/>
	<e path="Bool"/>
</f></willTrigger>
		<new public="1"><f a="?target">
	<c path="flash.events.IEventDispatcher"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.IBitmapDrawable" params="" file="/usr/lib/haxe/std/flash9/display/IBitmapDrawable.hx" extern="1" interface="1"/>
	<class path="flash.display.DisplayObject" params="" file="/usr/lib/haxe/std/flash9/display/DisplayObject.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<implements path="flash.display.IBitmapDrawable"/>
		<accessibilityProperties public="1"><c path="flash.accessibility.AccessibilityProperties"/></accessibilityProperties>
		<alpha public="1"><c path="Float"/></alpha>
		<blendMode public="1"><e path="flash.display.BlendMode"/></blendMode>
		<cacheAsBitmap public="1"><e path="Bool"/></cacheAsBitmap>
		<filters public="1"><c path="Array"><d/></c></filters>
		<height public="1"><c path="Float"/></height>
		<loaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></loaderInfo>
		<mask public="1"><c path="flash.display.DisplayObject"/></mask>
		<mouseX public="1" set="null"><c path="Float"/></mouseX>
		<mouseY public="1" set="null"><c path="Float"/></mouseY>
		<name public="1"><c path="String"/></name>
		<opaqueBackground public="1"><t path="Null"><t path="UInt"/></t></opaqueBackground>
		<parent public="1" set="null"><c path="flash.display.DisplayObjectContainer"/></parent>
		<root public="1" set="null"><c path="flash.display.DisplayObject"/></root>
		<rotation public="1"><c path="Float"/></rotation>
		<scale9Grid public="1"><c path="flash.geom.Rectangle"/></scale9Grid>
		<scaleX public="1"><c path="Float"/></scaleX>
		<scaleY public="1"><c path="Float"/></scaleY>
		<scrollRect public="1"><c path="flash.geom.Rectangle"/></scrollRect>
		<stage public="1" set="null"><c path="flash.display.Stage"/></stage>
		<transform public="1"><c path="flash.geom.Transform"/></transform>
		<visible public="1"><e path="Bool"/></visible>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<getBounds public="1"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getBounds>
		<getRect public="1"><f a="targetCoordinateSpace">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.geom.Rectangle"/>
</f></getRect>
		<globalToLocal public="1"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></globalToLocal>
		<hitTestObject public="1"><f a="obj">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></hitTestObject>
		<hitTestPoint public="1"><f a="x:y:?shapeFlag">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Bool"/>
</f></hitTestPoint>
		<localToGlobal public="1"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></localToGlobal>
	</class>
	<class path="flash.display.InteractiveObject" params="" file="/usr/lib/haxe/std/flash9/display/InteractiveObject.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<accessibilityImplementation public="1"><c path="flash.accessibility.AccessibilityImplementation"/></accessibilityImplementation>
		<contextMenu public="1"><c path="flash.ui.ContextMenu"/></contextMenu>
		<doubleClickEnabled public="1"><e path="Bool"/></doubleClickEnabled>
		<focusRect public="1"><d/></focusRect>
		<mouseEnabled public="1"><e path="Bool"/></mouseEnabled>
		<tabEnabled public="1"><e path="Bool"/></tabEnabled>
		<tabIndex public="1"><c path="Int"/></tabIndex>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.DisplayObjectContainer" params="" file="/usr/lib/haxe/std/flash9/display/DisplayObjectContainer.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<mouseChildren public="1"><e path="Bool"/></mouseChildren>
		<numChildren public="1" set="null"><c path="Int"/></numChildren>
		<tabChildren public="1"><e path="Bool"/></tabChildren>
		<textSnapshot public="1" set="null"><c path="flash.text.TextSnapshot"/></textSnapshot>
		<addChild public="1"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></addChild>
		<addChildAt public="1"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></addChildAt>
		<areInaccessibleObjectsUnderPoint public="1"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></areInaccessibleObjectsUnderPoint>
		<contains public="1"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<e path="Bool"/>
</f></contains>
		<getChildAt public="1"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildAt>
		<getChildByName public="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getChildByName>
		<getChildIndex public="1"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
</f></getChildIndex>
		<getObjectsUnderPoint public="1"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="flash.display.DisplayObject"/></c>
</f></getObjectsUnderPoint>
		<removeChild public="1"><f a="child">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChild>
		<removeChildAt public="1"><f a="index">
	<c path="Int"/>
	<c path="flash.display.DisplayObject"/>
</f></removeChildAt>
		<setChildIndex public="1"><f a="child:index">
	<c path="flash.display.DisplayObject"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setChildIndex>
		<swapChildren public="1"><f a="child1:child2">
	<c path="flash.display.DisplayObject"/>
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></swapChildren>
		<swapChildrenAt public="1"><f a="index1:index2">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></swapChildrenAt>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Sprite" params="" file="/usr/lib/haxe/std/flash9/display/Sprite.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<buttonMode public="1"><e path="Bool"/></buttonMode>
		<dropTarget public="1" set="null"><c path="flash.display.DisplayObject"/></dropTarget>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<hitArea public="1"><c path="flash.display.Sprite"/></hitArea>
		<soundTransform public="1"><c path="flash.media.SoundTransform"/></soundTransform>
		<useHandCursor public="1"><e path="Bool"/></useHandCursor>
		<startDrag public="1"><f a="?lockCenter:?bounds">
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></startDrag>
		<stopDrag public="1"><f a=""><e path="Void"/></f></stopDrag>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxegui.IToolTip" params="" file="./haxegui/IToolTip.hx" interface="1"><text public="1"><c path="String"/></text></class>
	<class path="haxegui.IMovable" params="" file="./haxegui/IMovable.hx" interface="1"><move public="1"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></move></class>
	<class path="haxegui.controls.Component" params="" file="./haxegui/controls/Component.hx">
		<extends path="flash.display.Sprite"/>
		<implements path="haxegui.IToolTip"/>
		<implements path="haxegui.IMovable"/>
		<box public="1"><c path="flash.geom.Rectangle"/></box>
		<disabled public="1"><e path="Bool"/></disabled>
		<validate public="1"><e path="Bool"/></validate>
		<text public="1"><c path="String"/></text>
		<margin public="1"><c path="flash.geom.Rectangle"/></margin>
		<move public="1" line="92">
			<f a="x:y">
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 </haxe_doc>
		</move>
		<setBox public="1" line="106">
			<f a="b">
				<c path="flash.geom.Rectangle"/>
				<c path="flash.geom.Rectangle"/>
			</f>
			<haxe_doc>
     * 
     </haxe_doc>
		</setBox>
		<hasFocus public="1" line="120"><f a=""><e path="Bool"/></f></hasFocus>
		<isValid public="1" line="130"><f a=""><e path="Bool"/></f></isValid>
		<new public="1" line="62"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * 
 * 
 * 
 * 
 </haxe_doc>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="haxegui.controls.Slider" params="" file="./haxegui/controls/Slider.hx">
		<extends path="haxegui.controls.Component"/>
		<handle public="1"><c path="haxegui.controls.Component"/></handle>
		<color public="1"><t path="UInt"/></color>
		<max public="1"><c path="Float"/></max>
		<init public="1" line="73">
			<f a="?initObj">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   * 
   * 
   * 
   * 
   </haxe_doc>
		</init>
		<onChanged public="1" line="154"><f a="?e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onChanged>
		<onMouseWheel public="1" line="163"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseWheel>
		<onRollOver public="1" line="175">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onRollOver>
		<onRollOut public="1" line="193">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onRollOut>
		<redraw public="1" line="202"><f a="color">
	<t path="UInt"/>
	<e path="Void"/>
</f></redraw>
		<onMouseDown line="226">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   *
   </haxe_doc>
		</onMouseDown>
		<onMouseMove public="1" line="245"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseMove>
		<onMouseUp line="253"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseUp>
		<new public="1" line="60"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.InterpolationMethod" params="" file="/usr/lib/haxe/std/flash9/display/InterpolationMethod.hx">
		<RGB/>
		<LINEAR_RGB/>
	</enum>
	<class path="haxe.FastList_hscript_Token" params="" file="/usr/lib/haxe/std/haxe/FastList.hx">
		<head public="1"><c path="haxe.FastCell_hscript_Token"/></head>
		<add public="1" line="49">
			<f a="item">
				<e path="hscript.Token"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the head of the list.
	</haxe_doc>
		</add>
		<first public="1" line="57">
			<f a=""><t path="Null"><e path="hscript.Token"/></t></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<pop public="1" line="66">
			<f a=""><t path="Null"><e path="hscript.Token"/></t></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" line="79">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<remove public="1" line="87">
			<f a="v">
				<e path="hscript.Token"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" line="107">
			<f a=""><t path="Iterator"><e path="hscript.Token"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" line="124">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<new public="1" line="43">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
	</class>
	<class path="haxegui.ITraceListener" params="" file="./haxegui/ITraceListener.hx" interface="1"><log public="1"><f a="e:?inf">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log></class>
	<class path="haxegui.controls.Input" params="" file="./haxegui/controls/Input.hx">
		<extends path="haxegui.controls.Component"/>
		<tf public="1"><c path="flash.text.TextField"/></tf>
		<init public="1" line="58">
			<f a="?initObj">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 * 
	 </haxe_doc>
		</init>
		<new public="1" line="48"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="feffects.easing.Cubic" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Cubic.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" line="5" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" line="10" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" line="15" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="List" params="T" file="/usr/lib/haxe/std/List.hx">
		<h><c path="Array"><d/></c></h>
		<q><c path="Array"><d/></c></q>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of elements in this list.
	</haxe_doc>
		</length>
		<add public="1" line="56">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the end of the list.
	</haxe_doc>
		</add>
		<push public="1" line="76">
			<f a="item">
				<c path="List.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Push an element at the beginning of the list.
	</haxe_doc>
		</push>
		<first public="1" line="100">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<last public="1" line="108">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Returns the last element of the list, or null
		if the list is empty.
	</haxe_doc>
		</last>
		<pop public="1" line="118">
			<f a=""><c path="List.T"/></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" line="132">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<clear public="1" line="139">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Makes the list empty.
	</haxe_doc>
		</clear>
		<remove public="1" line="149">
			<f a="v">
				<c path="List.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" line="190">
			<f a=""><t path="Iterator"><c path="List.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" line="229">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<join public="1" line="249">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Join the element of the list by using the separator [sep].
	</haxe_doc>
		</join>
		<filter public="1" line="268">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<e path="Bool"/>
				</f>
				<c path="List"><c path="List.T"/></c>
			</f>
			<haxe_doc>
		Returns a list filtered with [f]. The returned list
		will contain all elements [x] for which [f(x) = true].
	</haxe_doc>
		</filter>
		<map public="1" params="X" line="284">
			<f a="f">
				<f a="">
					<c path="List.T"/>
					<c path="map.X"/>
				</f>
				<c path="List"><c path="map.X"/></c>
			</f>
			<haxe_doc>
		Returns a new list where all elements have been converted
		by the function [f].
	</haxe_doc>
		</map>
		<new public="1" line="49">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. The list is composed of two-elements arrays
	that are chained together. It's optimized so that adding or removing an
	element doesn't imply to copy the whole array content everytime.
</haxe_doc>
	</class>
	<enum path="flash.net.URLLoaderDataFormat" params="" file="/usr/lib/haxe/std/flash9/net/URLLoaderDataFormat.hx">
		<VARIABLES/>
		<TEXT/>
		<BINARY/>
	</enum>
	<enum path="flash.text.TextFormatDisplay" params="" file="/usr/lib/haxe/std/flash9/text/TextFormatDisplay.hx">
		<INLINE/>
		<BLOCK/>
	</enum>
	<class path="Enum" params="" file="/usr/lib/haxe/std/Enum.hx" extern="1"><haxe_doc>
	An abstract type that represents an Enum.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<class path="flash.events.Event" params="" file="/usr/lib/haxe/std/flash9/events/Event.hx" extern="1">
		<ACTIVATE public="1" static="1"><c path="String"/></ACTIVATE>
		<ADDED public="1" static="1"><c path="String"/></ADDED>
		<CANCEL public="1" static="1"><c path="String"/></CANCEL>
		<CHANGE public="1" static="1"><c path="String"/></CHANGE>
		<CLOSE public="1" static="1"><c path="String"/></CLOSE>
		<COMPLETE public="1" static="1"><c path="String"/></COMPLETE>
		<CONNECT public="1" static="1"><c path="String"/></CONNECT>
		<DEACTIVATE public="1" static="1"><c path="String"/></DEACTIVATE>
		<ENTER_FRAME public="1" static="1"><c path="String"/></ENTER_FRAME>
		<ID3 public="1" static="1"><c path="String"/></ID3>
		<INIT public="1" static="1"><c path="String"/></INIT>
		<MOUSE_LEAVE public="1" static="1"><c path="String"/></MOUSE_LEAVE>
		<OPEN public="1" static="1"><c path="String"/></OPEN>
		<REMOVED public="1" static="1"><c path="String"/></REMOVED>
		<RENDER public="1" static="1"><c path="String"/></RENDER>
		<RESIZE public="1" static="1"><c path="String"/></RESIZE>
		<SCROLL public="1" static="1"><c path="String"/></SCROLL>
		<SELECT public="1" static="1"><c path="String"/></SELECT>
		<SOUND_COMPLETE public="1" static="1"><c path="String"/></SOUND_COMPLETE>
		<TAB_CHILDREN_CHANGE public="1" static="1"><c path="String"/></TAB_CHILDREN_CHANGE>
		<TAB_ENABLED_CHANGE public="1" static="1"><c path="String"/></TAB_ENABLED_CHANGE>
		<TAB_INDEX_CHANGE public="1" static="1"><c path="String"/></TAB_INDEX_CHANGE>
		<UNLOAD public="1" static="1"><c path="String"/></UNLOAD>
		<ADDED_TO_STAGE public="1" static="1">
			<c path="String"/>
			<haxe_doc> added in FP 9.0.28 </haxe_doc>
		</ADDED_TO_STAGE>
		<REMOVED_FROM_STAGE public="1" static="1">
			<c path="String"/>
			<haxe_doc> added in FP 9.0.28 </haxe_doc>
		</REMOVED_FROM_STAGE>
		<FULLSCREEN public="1" static="1">
			<c path="String"/>
			<haxe_doc> added in FP 9.0.28 </haxe_doc>
		</FULLSCREEN>
		<bubbles public="1" set="null"><e path="Bool"/></bubbles>
		<cancelable public="1" set="null"><e path="Bool"/></cancelable>
		<currentTarget public="1" set="null"><d/></currentTarget>
		<eventPhase public="1" set="null"><e path="flash.events.EventPhase"/></eventPhase>
		<target public="1" set="null"><d/></target>
		<type public="1" set="null"><c path="String"/></type>
		<clone public="1"><f a=""><c path="flash.events.Event"/></f></clone>
		<formatToString public="1"><f a="className:?p1:?p2:?p3:?p4:?p5">
	<c path="String"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<c path="String"/>
</f></formatToString>
		<isDefaultPrevented public="1"><f a=""><e path="Bool"/></f></isDefaultPrevented>
		<preventDefault public="1"><f a=""><e path="Void"/></f></preventDefault>
		<stopImmediatePropagation public="1"><f a=""><e path="Void"/></f></stopImmediatePropagation>
		<stopPropagation public="1"><f a=""><e path="Void"/></f></stopPropagation>
		<toString public="1"><f a=""><c path="String"/></f></toString>
		<new public="1"><f a="type:?bubbles:?cancelable">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.events.KeyboardEvent" params="" file="/usr/lib/haxe/std/flash9/events/KeyboardEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<KEY_DOWN public="1" static="1"><c path="String"/></KEY_DOWN>
		<KEY_UP public="1" static="1"><c path="String"/></KEY_UP>
		<altKey public="1"><e path="Bool"/></altKey>
		<charCode public="1"><t path="UInt"/></charCode>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<keyCode public="1"><t path="UInt"/></keyCode>
		<keyLocation public="1"><e path="flash.ui.KeyLocation"/></keyLocation>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<updateAfterEvent public="1"><f a=""><e path="Void"/></f></updateAfterEvent>
		<new public="1"><f a="type:?bubbles:?cancelable:?charCode:?keyCode:?keyLocation:?ctrlKey:?altKey:?shiftKey">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="flash.ui.KeyLocation"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxegui.ScrollPane" params="" file="./haxegui/ScrollPane.hx">
		<extends path="haxegui.controls.Component"/>
		<color public="1"><t path="UInt"/></color>
		<content public="1"><c path="flash.display.Sprite"/></content>
		<vert public="1"><c path="haxegui.controls.Scrollbar"/></vert>
		<horz public="1"><c path="haxegui.controls.Scrollbar"/></horz>
		<init public="1" line="69"><f a="?initObj">
	<d/>
	<e path="Void"/>
</f></init>
		<onResize public="1" line="130">
			<f a="e">
				<c path="haxegui.events.ResizeEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 </haxe_doc>
		</onResize>
		<new public="1" line="52"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="hscript.Const" params="" file="/home/gershon/haxelib/hscript/1,4,6/hscript/Expr.hx" module="hscript.Expr">
		<CString a="s"><c path="String"/></CString>
		<CInt32 a="v"><c path="haxe.Int32"/></CInt32>
		<CInt a="v"><c path="Int"/></CInt>
		<CFloat a="f"><c path="Float"/></CFloat>
	</enum>
	<enum path="hscript.Expr" params="" file="/home/gershon/haxelib/hscript/1,4,6/hscript/Expr.hx">
		<EWhile a="cond:e">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EWhile>
		<EVar a="n:?e">
			<c path="String"/>
			<e path="hscript.Expr"/>
		</EVar>
		<EUnop a="op:prefix:e">
			<c path="String"/>
			<e path="Bool"/>
			<e path="hscript.Expr"/>
		</EUnop>
		<ETry a="e:v:ecatch">
			<e path="hscript.Expr"/>
			<c path="String"/>
			<e path="hscript.Expr"/>
		</ETry>
		<EThrow a="e"><e path="hscript.Expr"/></EThrow>
		<EReturn a="?e"><e path="hscript.Expr"/></EReturn>
		<EParent a="e"><e path="hscript.Expr"/></EParent>
		<ENew a="cl:params">
			<c path="String"/>
			<c path="Array"><e path="hscript.Expr"/></c>
		</ENew>
		<EIf a="cond:e1:?e2">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EIf>
		<EIdent a="v"><c path="String"/></EIdent>
		<EFunction a="params:e:?name">
			<c path="Array"><c path="String"/></c>
			<e path="hscript.Expr"/>
			<c path="String"/>
		</EFunction>
		<EFor a="v:it:e">
			<c path="String"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EFor>
		<EField a="e:f">
			<e path="hscript.Expr"/>
			<c path="String"/>
		</EField>
		<EContinue/>
		<EConst a="c"><e path="hscript.Const"/></EConst>
		<ECall a="e:params">
			<e path="hscript.Expr"/>
			<c path="Array"><e path="hscript.Expr"/></c>
		</ECall>
		<EBreak/>
		<EBlock a="e"><c path="Array"><e path="hscript.Expr"/></c></EBlock>
		<EBinop a="op:e1:e2">
			<c path="String"/>
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EBinop>
		<EArrayDecl a="e"><c path="Array"><e path="hscript.Expr"/></c></EArrayDecl>
		<EArray a="e:index">
			<e path="hscript.Expr"/>
			<e path="hscript.Expr"/>
		</EArray>
	</enum>
	<enum path="hscript.Error" params="" file="/home/gershon/haxelib/hscript/1,4,6/hscript/Expr.hx" module="hscript.Expr">
		<EUnterminatedString/>
		<EUnterminatedComment/>
		<EUnknownVariable a="v"><c path="String"/></EUnknownVariable>
		<EUnexpected a="s"><c path="String"/></EUnexpected>
		<EInvalidOp a="op"><c path="String"/></EInvalidOp>
		<EInvalidIterator a="v"><c path="String"/></EInvalidIterator>
		<EInvalidChar a="c"><c path="Int"/></EInvalidChar>
		<EInvalidAccess a="f"><c path="String"/></EInvalidAccess>
	</enum>
	<class path="IntIter" params="" file="/usr/lib/haxe/std/IntIter.hx">
		<min><c path="Int"/></min>
		<max><c path="Int"/></max>
		<hasNext public="1" line="46">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Returns true if the iterator has other items, false otherwise.
	</haxe_doc>
		</hasNext>
		<next public="1" line="53">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Moves to the next item of the iterator.
	</haxe_doc>
		</next>
		<new public="1" line="38">
			<f a="min:max">
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Iterate from [min] (inclusive) to [max] (exclusive).
		If [max <= min], the iterator will not act as a countdown.
	]]></haxe_doc>
		</new>
		<haxe_doc>
	Integer iterator. Used for interval implementation.
</haxe_doc>
	</class>
	<class path="flash.filters.BitmapFilter" params="" file="/usr/lib/haxe/std/flash9/filters/BitmapFilter.hx" extern="1">
		<clone public="1"><f a=""><c path="flash.filters.BitmapFilter"/></f></clone>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.system.Capabilities" params="" file="/usr/lib/haxe/std/flash9/system/Capabilities.hx" extern="1">
		<_internal public="1" set="null" static="1"><t path="UInt"/></_internal>
		<avHardwareDisable public="1" set="null" static="1"><e path="Bool"/></avHardwareDisable>
		<hasAccessibility public="1" set="null" static="1"><e path="Bool"/></hasAccessibility>
		<hasAudio public="1" set="null" static="1"><e path="Bool"/></hasAudio>
		<hasAudioEncoder public="1" set="null" static="1"><e path="Bool"/></hasAudioEncoder>
		<hasEmbeddedVideo public="1" set="null" static="1"><e path="Bool"/></hasEmbeddedVideo>
		<hasIME public="1" set="null" static="1"><e path="Bool"/></hasIME>
		<hasMP3 public="1" set="null" static="1"><e path="Bool"/></hasMP3>
		<hasPrinting public="1" set="null" static="1"><e path="Bool"/></hasPrinting>
		<hasScreenBroadcast public="1" set="null" static="1"><e path="Bool"/></hasScreenBroadcast>
		<hasScreenPlayback public="1" set="null" static="1"><e path="Bool"/></hasScreenPlayback>
		<hasStreamingAudio public="1" set="null" static="1"><e path="Bool"/></hasStreamingAudio>
		<hasStreamingVideo public="1" set="null" static="1"><e path="Bool"/></hasStreamingVideo>
		<hasTLS public="1" set="null" static="1"><e path="Bool"/></hasTLS>
		<hasVideoEncoder public="1" set="null" static="1"><e path="Bool"/></hasVideoEncoder>
		<isDebugger public="1" set="null" static="1"><e path="Bool"/></isDebugger>
		<language public="1" set="null" static="1"><c path="String"/></language>
		<localFileReadDisable public="1" set="null" static="1"><e path="Bool"/></localFileReadDisable>
		<manufacturer public="1" set="null" static="1"><c path="String"/></manufacturer>
		<os public="1" set="null" static="1"><c path="String"/></os>
		<pixelAspectRatio public="1" set="null" static="1"><c path="Float"/></pixelAspectRatio>
		<playerType public="1" set="null" static="1"><c path="String"/></playerType>
		<screenColor public="1" set="null" static="1"><c path="String"/></screenColor>
		<screenDPI public="1" set="null" static="1"><c path="Float"/></screenDPI>
		<screenResolutionX public="1" set="null" static="1"><c path="Float"/></screenResolutionX>
		<screenResolutionY public="1" set="null" static="1"><c path="Float"/></screenResolutionY>
		<serverString public="1" set="null" static="1"><c path="String"/></serverString>
		<version public="1" set="null" static="1"><c path="String"/></version>
	</class>
	<class path="String" params="" file="/usr/lib/haxe/std/String.hx" extern="1">
		<fromCharCode public="1" static="1"><f a="code">
	<c path="Int"/>
	<c path="String"/>
</f></fromCharCode>
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The number of characters in the String.
	</haxe_doc>
		</length>
		<toUpperCase public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been uppercased.
	</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an String where all characters have been lowercased.
	</haxe_doc>
		</toLowerCase>
		<charAt public="1">
			<f a="index">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the character at the given position.
		Returns the empty String if outside of String bounds.
	</haxe_doc>
		</charAt>
		<charCodeAt public="1">
			<f a="index">
				<c path="Int"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Returns the character code at the given position.
		Returns [null] if outside of String bounds.
	</haxe_doc>
		</charCodeAt>
		<indexOf public="1">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of first occurence of [value]
		Returns [1-1] if [value] is not found.
		The optional [startIndex] parameter allows you to specify at which character to start searching.
		The position returned is still relative to the beginning of the string.
	</haxe_doc>
		</indexOf>
		<lastIndexOf public="1">
			<f a="value:?startIndex">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Similar to [indexOf] but returns the latest index.
	</haxe_doc>
		</lastIndexOf>
		<split public="1">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split the string using the specified delimiter.
	</haxe_doc>
		</split>
		<substr public="1">
			<f a="pos:?len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a part of the String, taking [len] characters starting from [pos].
		If [len] is not specified, it takes all the remaining characters.
	</haxe_doc>
		</substr>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the String itself.
	</haxe_doc>
		</toString>
		<cca><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></cca>
		<new public="1">
			<f a="string">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a copy from a given String.
	</haxe_doc>
		</new>
		<haxe_doc>
	The basic String class.
</haxe_doc>
	</class>
	<class path="Hash" params="T" file="/usr/lib/haxe/std/Hash.hx">
		<h><c path="flash.utils.Dictionary"/></h>
		<set public="1" line="63">
			<f a="key:value">
				<c path="String"/>
				<c path="Hash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" line="80">
			<f a="key">
				<c path="String"/>
				<t path="Null"><c path="Hash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" line="102">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" line="133">
			<f a="key">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" line="165">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" line="195">
			<f a=""><t path="Iterator"><c path="Hash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" line="240">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" line="38">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [String] as keys.
	Other kind of keys are not possible on all platforms since they
	can't always be implemented efficiently.
</haxe_doc>
	</class>
	<class path="haxegui.controls.UiList" params="" file="./haxegui/controls/UiList.hx">
		<extends path="haxegui.controls.Component"/>
		<header public="1"><c path="flash.display.Sprite"/></header>
		<data public="1"><d/></data>
		<sortReverse public="1"><e path="Bool"/></sortReverse>
		<color><t path="UInt"/></color>
		<dragItem><c path="Int"/></dragItem>
		<init public="1" line="80"><f a="?initObj">
	<d/>
	<e path="Void"/>
</f></init>
		<onMouseDown public="1" line="120"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseDown>
		<onMouseUp public="1" line="136"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseUp>
		<onRollOver public="1" line="147"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onRollOver>
		<onRollOut public="1" line="162"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onRollOut>
		<shrink public="1" line="181"><f a=""><e path="Void"/></f></shrink>
		<drawHeader public="1" line="197"><f a="?color">
	<t path="UInt"/>
	<e path="Void"/>
</f></drawHeader>
		<redraw public="1" line="215"><f a=""><e path="Void"/></f></redraw>
		<onHeaderMouseDown public="1" line="299"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onHeaderMouseDown>
		<onHeaderMouseUp public="1" line="311"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onHeaderMouseUp>
		<new public="1" line="69"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * 
 * 
 * 
 * 
 </haxe_doc>
	</class>
	<class path="Array" params="T" file="/usr/lib/haxe/std/Array.hx" extern="1">
		<length public="1" set="null">
			<c path="Int"/>
			<haxe_doc>
		The length of the Array
	</haxe_doc>
		</length>
		<concat public="1">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Returns a new Array by appending [a] to [this].
	</haxe_doc>
		</concat>
		<join public="1">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a representation of an array with [sep] for separating each element.
	</haxe_doc>
		</join>
		<pop public="1">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the last element of the array and returns it.
	</haxe_doc>
		</pop>
		<push public="1">
			<f a="x">
				<c path="Array.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the end of the array.
	</haxe_doc>
		</push>
		<reverse public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Reverse the order of elements of the Array.
	</haxe_doc>
		</reverse>
		<shift public="1">
			<f a=""><t path="Null"><c path="Array.T"/></t></f>
			<haxe_doc>
		Removes the first element and returns it.
	</haxe_doc>
		</shift>
		<slice public="1">
			<f a="pos:?end">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Copies the range of the array starting at [pos] up to,
		but not including, [end]. Both [pos] and [end] can be
		negative to count from the end: -1 is the last item in
		the array.
	</haxe_doc>
		</slice>
		<sort public="1">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<c path="Int"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
		Sort the Array according to the comparison function [f].
		[f(x,y)] should return [0] if [x == y], [>0] if [x > y]
		and [<0] if [x < y].
	]]></haxe_doc>
		</sort>
		<splice public="1">
			<f a="pos:len">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>
		Removes [len] elements starting from [pos] an returns them.
	</haxe_doc>
		</splice>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the Array content.
	</haxe_doc>
		</toString>
		<unshift public="1">
			<f a="x">
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the element [x] at the start of the array.
	</haxe_doc>
		</unshift>
		<insert public="1">
			<f a="pos:x">
				<c path="Int"/>
				<c path="Array.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts the element [x] at the position [pos].
		All elements after [pos] are moved one index ahead.
	</haxe_doc>
		</insert>
		<remove public="1">
			<f a="x">
				<c path="Array.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes the first occurence of [x].
		Returns false if [x] was not present.
		Elements are compared by using standard equality.
	</haxe_doc>
		</remove>
		<copy public="1">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>
		Returns a copy of the Array. The values are not
		copied, only the Array structure.
	</haxe_doc>
		</copy>
		<iterator public="1">
			<f a=""><t path="Iterator"><t path="Null"><c path="Array.T"/></t></t></f>
			<haxe_doc>
		Returns an iterator of the Array values.
	</haxe_doc>
		</iterator>
		<new public="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new Array.
	</haxe_doc>
		</new>
		<haxe_doc>
	An Array is a storage for values. You can access it using indexes or
	with its API. On the server side, it's often better to use a [List] which
	is less memory and CPU consuming, unless you really need indexed access.
</haxe_doc>
	</class>
	<class path="flash.events.FocusEvent" params="" file="/usr/lib/haxe/std/flash9/events/FocusEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<FOCUS_IN public="1" static="1"><c path="String"/></FOCUS_IN>
		<FOCUS_OUT public="1" static="1"><c path="String"/></FOCUS_OUT>
		<KEY_FOCUS_CHANGE public="1" static="1"><c path="String"/></KEY_FOCUS_CHANGE>
		<MOUSE_FOCUS_CHANGE public="1" static="1"><c path="String"/></MOUSE_FOCUS_CHANGE>
		<keyCode public="1"><t path="UInt"/></keyCode>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<new public="1"><f a="type:?bubbles:?cancelable:?relatedObject:?shiftKey:?keyCode">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.StyleSheet" params="" file="/usr/lib/haxe/std/flash9/text/StyleSheet.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<styleNames public="1" set="null"><c path="Array"><d/></c></styleNames>
		<clear public="1"><f a=""><e path="Void"/></f></clear>
		<getStyle public="1"><f a="styleName">
	<c path="String"/>
	<d/>
</f></getStyle>
		<parseCSS public="1"><f a="CSSText">
	<c path="String"/>
	<e path="Void"/>
</f></parseCSS>
		<setStyle public="1"><f a="styleName:styleObject">
	<c path="String"/>
	<d/>
	<e path="Void"/>
</f></setStyle>
		<transform public="1"><f a="formatObject">
	<d/>
	<c path="flash.text.TextFormat"/>
</f></transform>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.MovieClip" params="" file="/usr/lib/haxe/std/flash9/display/MovieClip.hx" extern="1">
		<extends path="flash.display.Sprite"/>
		<currentFrame public="1" set="null"><c path="Int"/></currentFrame>
		<currentLabel public="1" set="null"><c path="String"/></currentLabel>
		<currentLabels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></currentLabels>
		<currentScene public="1" set="null"><c path="flash.display.Scene"/></currentScene>
		<enabled public="1"><e path="Bool"/></enabled>
		<framesLoaded public="1" set="null"><c path="Int"/></framesLoaded>
		<scenes public="1" set="null"><c path="Array"><c path="flash.display.Scene"/></c></scenes>
		<totalFrames public="1" set="null"><c path="Int"/></totalFrames>
		<trackAsMenu public="1"><e path="Bool"/></trackAsMenu>
		<addFrameScript public="1"><f a="?p1:?p2:?p3:?p4:?p5">
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<e path="Void"/>
</f></addFrameScript>
		<gotoAndPlay public="1"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndPlay>
		<gotoAndStop public="1"><f a="frame:?scene">
	<d/>
	<c path="String"/>
	<e path="Void"/>
</f></gotoAndStop>
		<nextFrame public="1"><f a=""><e path="Void"/></f></nextFrame>
		<nextScene public="1"><f a=""><e path="Void"/></f></nextScene>
		<play public="1"><f a=""><e path="Void"/></f></play>
		<prevFrame public="1"><f a=""><e path="Void"/></f></prevFrame>
		<prevScene public="1"><f a=""><e path="Void"/></f></prevScene>
		<stop public="1"><f a=""><e path="Void"/></f></stop>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="IntHash" params="T" file="/usr/lib/haxe/std/IntHash.hx">
		<h><c path="flash.utils.Dictionary"/></h>
		<set public="1" line="60">
			<f a="key:value">
				<c path="Int"/>
				<c path="IntHash.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set a value for the given key.
	</haxe_doc>
		</set>
		<get public="1" line="75">
			<f a="key">
				<c path="Int"/>
				<t path="Null"><c path="IntHash.T"/></t>
			</f>
			<haxe_doc>
		Get a value for the given key.
	</haxe_doc>
		</get>
		<exists public="1" line="97">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value exists for the given key.
		In particular, it's useful to tells if a key has
		a [null] value versus no value.
	</haxe_doc>
		</exists>
		<remove public="1" line="119">
			<f a="key">
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a hashtable entry. Returns [true] if
		there was such entry.
	</haxe_doc>
		</remove>
		<keys public="1" line="148">
			<f a=""><t path="Iterator"><c path="Int"/></t></f>
			<haxe_doc>
		Returns an iterator of all keys in the hashtable.
	</haxe_doc>
		</keys>
		<iterator public="1" line="180">
			<f a=""><t path="Iterator"><c path="IntHash.T"/></t></f>
			<haxe_doc>
		Returns an iterator of all values in the hashtable.
	</haxe_doc>
		</iterator>
		<toString public="1" line="220">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns an displayable representation of the hashtable content.
	</haxe_doc>
		</toString>
		<new public="1" line="37">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty hashtable.
	</haxe_doc>
		</new>
		<haxe_doc>
	Hashtable over a set of elements, using [Int] as keys.
	On Flash and Javascript, the underlying structure is an Object.
</haxe_doc>
	</class>
	<class path="flash.text.TextSnapshot" params="" file="/usr/lib/haxe/std/flash9/text/TextSnapshot.hx" extern="1">
		<charCount public="1" set="null"><c path="Int"/></charCount>
		<findText public="1"><f a="beginIndex:textToFind:caseSensitive">
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<c path="Int"/>
</f></findText>
		<getSelected public="1"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
</f></getSelected>
		<getSelectedText public="1"><f a="?includeLineEndings">
	<e path="Bool"/>
	<c path="String"/>
</f></getSelectedText>
		<getText public="1"><f a="beginIndex:endIndex:?includeLineEndings">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<c path="String"/>
</f></getText>
		<getTextRunInfo public="1"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRunInfo>
		<hitTestTextNearPos public="1"><f a="x:y:?maxDistance">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></hitTestTextNearPos>
		<setSelectColor public="1"><f a="?hexColor">
	<t path="UInt"/>
	<e path="Void"/>
</f></setSelectColor>
		<setSelected public="1"><f a="beginIndex:endIndex:select">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></setSelected>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.events.MouseEvent" params="" file="/usr/lib/haxe/std/flash9/events/MouseEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<CLICK public="1" static="1"><c path="String"/></CLICK>
		<DOUBLE_CLICK public="1" static="1"><c path="String"/></DOUBLE_CLICK>
		<MOUSE_DOWN public="1" static="1"><c path="String"/></MOUSE_DOWN>
		<MOUSE_MOVE public="1" static="1"><c path="String"/></MOUSE_MOVE>
		<MOUSE_OUT public="1" static="1"><c path="String"/></MOUSE_OUT>
		<MOUSE_OVER public="1" static="1"><c path="String"/></MOUSE_OVER>
		<MOUSE_UP public="1" static="1"><c path="String"/></MOUSE_UP>
		<MOUSE_WHEEL public="1" static="1"><c path="String"/></MOUSE_WHEEL>
		<ROLL_OUT public="1" static="1"><c path="String"/></ROLL_OUT>
		<ROLL_OVER public="1" static="1"><c path="String"/></ROLL_OVER>
		<altKey public="1"><e path="Bool"/></altKey>
		<buttonDown public="1"><e path="Bool"/></buttonDown>
		<ctrlKey public="1"><e path="Bool"/></ctrlKey>
		<delta public="1"><c path="Int"/></delta>
		<localX public="1"><c path="Float"/></localX>
		<localY public="1"><c path="Float"/></localY>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<shiftKey public="1"><e path="Bool"/></shiftKey>
		<stageX public="1" set="null"><c path="Float"/></stageX>
		<stageY public="1" set="null"><c path="Float"/></stageY>
		<updateAfterEvent public="1"><f a=""><e path="Void"/></f></updateAfterEvent>
		<new public="1"><f a="type:?bubbles:?cancelable:?localX:?localY:?relatedObject:?ctrlKey:?altKey:?shiftKey:?buttonDown:?delta">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.display.InteractiveObject"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxegui.events.ResizeEvent" params="" file="./haxegui/events/ResizeEvent.hx">
		<extends path="flash.events.MouseEvent"/>
		<RESIZE public="1" line="22" static="1"><c path="String"/></RESIZE>
		<oldHeight public="1"><c path="Float"/></oldHeight>
		<oldWidth public="1"><c path="Float"/></oldWidth>
		<new public="1" line="6"><f a="type:?bubbles:?cancelable:?oldWidth:?oldHeight">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.ui.Keyboard" params="" file="/usr/lib/haxe/std/flash9/ui/Keyboard.hx" extern="1">
		<BACKSPACE public="1" static="1"><t path="UInt"/></BACKSPACE>
		<CAPS_LOCK public="1" static="1"><t path="UInt"/></CAPS_LOCK>
		<CONTROL public="1" static="1"><t path="UInt"/></CONTROL>
		<DELETE public="1" static="1"><t path="UInt"/></DELETE>
		<DOWN public="1" static="1"><t path="UInt"/></DOWN>
		<END public="1" static="1"><t path="UInt"/></END>
		<ENTER public="1" static="1"><t path="UInt"/></ENTER>
		<ESCAPE public="1" static="1"><t path="UInt"/></ESCAPE>
		<F1 public="1" static="1"><t path="UInt"/></F1>
		<F10 public="1" static="1"><t path="UInt"/></F10>
		<F11 public="1" static="1"><t path="UInt"/></F11>
		<F12 public="1" static="1"><t path="UInt"/></F12>
		<F13 public="1" static="1"><t path="UInt"/></F13>
		<F14 public="1" static="1"><t path="UInt"/></F14>
		<F15 public="1" static="1"><t path="UInt"/></F15>
		<F2 public="1" static="1"><t path="UInt"/></F2>
		<F3 public="1" static="1"><t path="UInt"/></F3>
		<F4 public="1" static="1"><t path="UInt"/></F4>
		<F5 public="1" static="1"><t path="UInt"/></F5>
		<F6 public="1" static="1"><t path="UInt"/></F6>
		<F7 public="1" static="1"><t path="UInt"/></F7>
		<F8 public="1" static="1"><t path="UInt"/></F8>
		<F9 public="1" static="1"><t path="UInt"/></F9>
		<HOME public="1" static="1"><t path="UInt"/></HOME>
		<INSERT public="1" static="1"><t path="UInt"/></INSERT>
		<LEFT public="1" static="1"><t path="UInt"/></LEFT>
		<NUMPAD_0 public="1" static="1"><t path="UInt"/></NUMPAD_0>
		<NUMPAD_1 public="1" static="1"><t path="UInt"/></NUMPAD_1>
		<NUMPAD_2 public="1" static="1"><t path="UInt"/></NUMPAD_2>
		<NUMPAD_3 public="1" static="1"><t path="UInt"/></NUMPAD_3>
		<NUMPAD_4 public="1" static="1"><t path="UInt"/></NUMPAD_4>
		<NUMPAD_5 public="1" static="1"><t path="UInt"/></NUMPAD_5>
		<NUMPAD_6 public="1" static="1"><t path="UInt"/></NUMPAD_6>
		<NUMPAD_7 public="1" static="1"><t path="UInt"/></NUMPAD_7>
		<NUMPAD_8 public="1" static="1"><t path="UInt"/></NUMPAD_8>
		<NUMPAD_9 public="1" static="1"><t path="UInt"/></NUMPAD_9>
		<NUMPAD_ADD public="1" static="1"><t path="UInt"/></NUMPAD_ADD>
		<NUMPAD_DECIMAL public="1" static="1"><t path="UInt"/></NUMPAD_DECIMAL>
		<NUMPAD_DIVIDE public="1" static="1"><t path="UInt"/></NUMPAD_DIVIDE>
		<NUMPAD_ENTER public="1" static="1"><t path="UInt"/></NUMPAD_ENTER>
		<NUMPAD_MULTIPLY public="1" static="1"><t path="UInt"/></NUMPAD_MULTIPLY>
		<NUMPAD_SUBTRACT public="1" static="1"><t path="UInt"/></NUMPAD_SUBTRACT>
		<PAGE_DOWN public="1" static="1"><t path="UInt"/></PAGE_DOWN>
		<PAGE_UP public="1" static="1"><t path="UInt"/></PAGE_UP>
		<RIGHT public="1" static="1"><t path="UInt"/></RIGHT>
		<SHIFT public="1" static="1"><t path="UInt"/></SHIFT>
		<SPACE public="1" static="1"><t path="UInt"/></SPACE>
		<TAB public="1" static="1"><t path="UInt"/></TAB>
		<UP public="1" static="1"><t path="UInt"/></UP>
		<capsLock public="1" set="null" static="1"><e path="Bool"/></capsLock>
		<numLock public="1" set="null" static="1"><e path="Bool"/></numLock>
		<isAccessible public="1" static="1"><f a=""><e path="Bool"/></f></isAccessible>
	</class>
	<class path="haxegui.events.DragEvent" params="" file="./haxegui/events/DragEvent.hx">
		<extends path="flash.events.MouseEvent"/>
		<DRAG_COMPLETE public="1" line="18" static="1"><c path="String"/></DRAG_COMPLETE>
		<DRAG_DROP static="1"><c path="String"/></DRAG_DROP>
		<DRAG_ENTER static="1"><c path="String"/></DRAG_ENTER>
		<DRAG_EXIT static="1"><c path="String"/></DRAG_EXIT>
		<DRAG_OVER public="1" line="22" static="1"><c path="String"/></DRAG_OVER>
		<DRAG_START public="1" line="23" static="1"><c path="String"/></DRAG_START>
		<action><c path="String"/></action>
		<dragInitiator><c path="haxegui.controls.Component"/></dragInitiator>
		<draggedItem><d/></draggedItem>
		<new public="1" line="7"><f a="type:?bubbles:?cancelable:?ctrlKey:?altKey:?shiftKey">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.utils.Dictionary" params="" file="/usr/lib/haxe/std/flash9/utils/Dictionary.hx" extern="1"><new public="1"><f a="?weakKeys">
	<e path="Bool"/>
	<e path="Void"/>
</f></new></class>
	<class path="StringTools" params="" file="/usr/lib/haxe/std/StringTools.hx">
		<urlEncode public="1" line="38" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode an URL by using the standard format.
	</haxe_doc>
		</urlEncode>
		<urlDecode public="1" line="59" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Decode an URL using the standard format.
	</haxe_doc>
		</urlDecode>
		<htmlEscape public="1" line="80" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Escape HTML special characters of the string.
	</haxe_doc>
		</htmlEscape>
		<htmlUnescape public="1" line="87" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Unescape HTML special characters of the string.
	</haxe_doc>
		</htmlUnescape>
		<startsWith public="1" line="98" static="1">
			<f a="s:start">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] starts with the string [start].
	</haxe_doc>
		</startsWith>
		<endsWith public="1" line="105" static="1">
			<f a="s:end">
				<c path="String"/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the string [s] ends with the string [end].
	</haxe_doc>
		</endsWith>
		<isSpace public="1" line="114" static="1">
			<f a="s:pos">
				<c path="String"/>
				<c path="Int"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the character in the string [s] at position [pos] is a space.
	</haxe_doc>
		</isSpace>
		<ltrim public="1" line="122" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the left of the String [s].
	</haxe_doc>
		</ltrim>
		<rtrim public="1" line="141" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the right of the String [s].
	</haxe_doc>
		</rtrim>
		<trim public="1" line="161" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Removes spaces at the beginning and the end of the String [s].
	</haxe_doc>
		</trim>
		<rpad public="1" line="172" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its right until it reach [l] characters.
	</haxe_doc>
		</rpad>
		<lpad public="1" line="194" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Pad the string [s] by appending [c] at its left until it reach [l] characters.
	</haxe_doc>
		</lpad>
		<replace public="1" line="219" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replace all occurences of the string [sub] in the string [s] by the string [by].
	</haxe_doc>
		</replace>
		<hex public="1" line="230" static="1">
			<f a="n:?digits">
				<c path="Int"/>
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Encode a number into a hexadecimal representation, with an optional number of zeros for left padding.
	</haxe_doc>
		</hex>
		<haxe_doc>
	The StringTools class contains some extra functionalities for [String]
	manipulation. It's stored in a different class in order to prevent
	the standard [String] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="haxe.io.Bytes" params="" file="/usr/lib/haxe/std/haxe/io/Bytes.hx">
		<alloc public="1" line="211" static="1"><f a="length">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" line="239" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" line="278" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<length public="1" set="null"><c path="Int"/></length>
		<b><t path="haxe.io.BytesData"/></b>
		<get public="1" line="37"><f a="pos">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<set public="1" line="51"><f a="pos:v">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></set>
		<blit public="1" line="65"><f a="pos:src:srcpos:len">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></blit>
		<sub public="1" line="93"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" line="112"><f a="other">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
</f></compare>
		<readString public="1" line="148"><f a="pos:len">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<toString public="1" line="192"><f a=""><c path="String"/></f></toString>
		<getData public="1" line="207"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new line="32"><f a="length:b">
	<c path="Int"/>
	<t path="haxe.io.BytesData"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.filters.DropShadowFilter" params="" file="/usr/lib/haxe/std/flash9/filters/DropShadowFilter.hx" extern="1">
		<extends path="flash.filters.BitmapFilter"/>
		<alpha public="1"><c path="Float"/></alpha>
		<angle public="1"><c path="Float"/></angle>
		<blurX public="1"><c path="Float"/></blurX>
		<blurY public="1"><c path="Float"/></blurY>
		<color public="1"><t path="UInt"/></color>
		<distance public="1"><c path="Float"/></distance>
		<hideObject public="1"><e path="Bool"/></hideObject>
		<inner public="1"><e path="Bool"/></inner>
		<knockout public="1"><e path="Bool"/></knockout>
		<quality public="1"><c path="Int"/></quality>
		<strength public="1"><c path="Float"/></strength>
		<new public="1"><f a="?distance:?angle:?color:?alpha:?blurX:?blurY:?strength:?quality:?inner:?knockout:?hideObject">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.ui.ContextMenuBuiltInItems" params="" file="/usr/lib/haxe/std/flash9/ui/ContextMenuBuiltInItems.hx" extern="1">
		<forwardAndBack public="1"><e path="Bool"/></forwardAndBack>
		<loop public="1"><e path="Bool"/></loop>
		<play public="1"><e path="Bool"/></play>
		<print public="1"><e path="Bool"/></print>
		<quality public="1"><e path="Bool"/></quality>
		<rewind public="1"><e path="Bool"/></rewind>
		<save public="1"><e path="Bool"/></save>
		<zoom public="1"><e path="Bool"/></zoom>
		<clone public="1"><f a=""><c path="flash.ui.ContextMenuBuiltInItems"/></f></clone>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.Boot" params="" file="/usr/lib/haxe/std/flash9/Boot.hx">
		<extends path="flash.display.MovieClip"/>
		<init static="1"><f a=""><e path="Void"/></f></init>
		<tf static="1"><c path="flash.text.TextField"/></tf>
		<lines static="1"><c path="Array"><c path="String"/></c></lines>
		<lastError static="1"><c path="flash.Error"/></lastError>
		<skip_constructor public="1" line="34" static="1"><e path="Bool"/></skip_constructor>
		<enum_to_string public="1" line="89" static="1"><f a="e">
	<a>
		<tag><c path="String"/></tag>
		<params><c path="Array"><d/></c></params>
	</a>
	<c path="String"/>
</f></enum_to_string>
		<__instanceof public="1" line="95" static="1"><f a="v:t">
	<d/>
	<d/>
	<e path="Bool"/>
</f></__instanceof>
		<__clear_trace public="1" line="105" static="1"><f a=""><e path="Void"/></f></__clear_trace>
		<__set_trace_color public="1" line="113" static="1"><f a="rgb">
	<t path="UInt"/>
	<e path="Void"/>
</f></__set_trace_color>
		<getTrace public="1" line="117" static="1"><f a=""><c path="flash.text.TextField"/></f></getTrace>
		<__trace public="1" line="133" static="1"><f a="v:pos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></__trace>
		<__string_rec public="1" line="147" static="1"><f a="v:str">
	<d/>
	<c path="String"/>
	<c path="String"/>
</f></__string_rec>
		<__unprotect__ line="187" static="1"><f a="s">
	<c path="String"/>
	<c path="String"/>
</f></__unprotect__>
		<new public="1" line="36"><f a="?mc">
	<c path="flash.display.MovieClip"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.CapsStyle" params="" file="/usr/lib/haxe/std/flash9/display/CapsStyle.hx">
		<SQUARE/>
		<ROUND/>
		<NONE/>
	</enum>
	<class path="haxegui.IContainer" params="" file="./haxegui/IContainer.hx" interface="1"/>
	<class path="haxegui.Container" params="" file="./haxegui/Container.hx">
		<extends path="haxegui.controls.Component"/>
		<implements path="haxegui.IContainer"/>
		<color public="1"><t path="UInt"/></color>
		<_clip><e path="Bool"/></_clip>
		<init public="1" line="69"><f a="?initObj">
	<d/>
	<e path="Void"/>
</f></init>
		<onResize public="1" line="122">
			<f a="e">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onResize>
		<redraw public="1" line="163">
			<f a="?e">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</redraw>
		<new public="1" line="54"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.display.FrameLabel" params="" file="/usr/lib/haxe/std/flash9/display/FrameLabel.hx" extern="1">
		<frame public="1" set="null"><c path="Int"/></frame>
		<name public="1" set="null"><c path="String"/></name>
		<new public="1"><f a="name:frame">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="/usr/lib/haxe/std/haxe/io/BytesBuffer.hx">
		<b><c path="flash.utils.ByteArray"/></b>
		<addByte public="1" line="53"><f a="byte">
	<c path="Int"/>
	<e path="Void"/>
</f></addByte>
		<add public="1" line="67"><f a="src">
	<c path="haxe.io.Bytes"/>
	<e path="Void"/>
</f></add>
		<addBytes public="1" line="83"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></addBytes>
		<getBytes public="1" line="112">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>
		Returns either a copy or a reference of the current bytes.
		Once called, the buffer can no longer be used.
	</haxe_doc>
		</getBytes>
		<new public="1" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxe.rtti.Infos" params="" file="/usr/lib/haxe/std/haxe/rtti/Infos.hx" interface="1"><haxe_doc>
	This is a magic interface. When a class implements [haxe.rtti.Infos], this class and all its
	subclass will get an additional static field [__rtti] storing the class type informations.
</haxe_doc></class>
	<class path="flash.geom.Transform" params="" file="/usr/lib/haxe/std/flash9/geom/Transform.hx" extern="1">
		<colorTransform public="1"><c path="flash.geom.ColorTransform"/></colorTransform>
		<concatenatedColorTransform public="1" set="null"><c path="flash.geom.ColorTransform"/></concatenatedColorTransform>
		<concatenatedMatrix public="1" set="null"><c path="flash.geom.Matrix"/></concatenatedMatrix>
		<matrix public="1"><c path="flash.geom.Matrix"/></matrix>
		<pixelBounds public="1" set="null"><c path="flash.geom.Rectangle"/></pixelBounds>
		<new public="1"><f a="displayObject">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxegui.Image" params="" file="./haxegui/Image.hx">
		<extends path="haxegui.controls.Component"/>
		<init public="1" line="45"><f a="initObj">
	<d/>
	<e path="Void"/>
</f></init>
		<onComplete line="64"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onComplete>
		<new public="1" line="40"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.TextFieldAutoSize" params="" file="/usr/lib/haxe/std/flash9/text/TextFieldAutoSize.hx">
		<RIGHT/>
		<NONE/>
		<LEFT/>
		<CENTER/>
	</enum>
	<class path="Class" params="T" file="/usr/lib/haxe/std/Class.hx" extern="1"><haxe_doc>
	An abstract type that represents a Class.
	See [Type] for the haXe Reflection API.
</haxe_doc></class>
	<enum path="flash.display.GradientType" params="" file="/usr/lib/haxe/std/flash9/display/GradientType.hx">
		<RADIAL/>
		<LINEAR/>
	</enum>
	<class path="haxegui.Window" params="" file="./haxegui/Window.hx">
		<extends path="haxegui.controls.Component"/>
		<titlebar public="1"><c path="haxegui.Titlebar"/></titlebar>
		<frame public="1"><c path="flash.display.Sprite"/></frame>
		<br public="1"><c path="flash.display.Sprite"/></br>
		<bl public="1"><c path="flash.display.Sprite"/></bl>
		<color public="1"><t path="UInt"/></color>
		<type public="1"><e path="haxegui.WindowType"/></type>
		<sizeable><e path="Bool"/></sizeable>
		<init public="1" line="306">
			<f a="?initObj">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
    * 
    * Initialize a new window
    * 
    * @param initObj Dynamic object containing attributes
    * 
    * 
    </haxe_doc>
		</init>
		<isSizeable public="1" line="381"><f a=""><e path="Bool"/></f></isSizeable>
		<onMove public="1" line="388"><f a="e">
	<c path="haxegui.events.MoveEvent"/>
	<e path="Void"/>
</f></onMove>
		<draw public="1" line="400">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
     * 
     * 
     * 
     * 
     </haxe_doc>
		</draw>
		<onRollOut public="1" line="476">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * 
     * 
     </haxe_doc>
		</onRollOut>
		<onRollOver public="1" line="492">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * 
     * 
     </haxe_doc>
		</onRollOver>
		<onMouseMove public="1" line="505">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * 
     * 
     * 
     </haxe_doc>
		</onMouseMove>
		<onResize public="1" line="559">
			<f a="e">
				<c path="haxegui.events.ResizeEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Resize listener to position corners and redraw frame
     * 
     * 
     </haxe_doc>
		</onResize>
		<onMouseDown public="1" line="577">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   *
   </haxe_doc>
		</onMouseDown>
		<onMouseUp public="1" line="623">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   * 
   * 
   * 
   </haxe_doc>
		</onMouseUp>
		<redrawFrame public="1" line="647">
			<f a="fill:color">
				<t path="UInt"/>
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * Redraw just frame
     * 
     </haxe_doc>
		</redrawFrame>
		<redraw public="1" line="666">
			<f a="e">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
 * Redraw entire window
 *
 </haxe_doc>
		</redraw>
		<onRaise public="1" line="724"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onRaise>
		<new public="1" line="282"><f a="?parent:?name:?x:?y:?width:?height:?sizeable">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="haxegui.Console" params="" file="./haxegui/Console.hx">
		<extends path="haxegui.Window"/>
		<implements path="haxegui.ITraceListener"/>
		<parser><c path="hscript.Parser"/></parser>
		<history><c path="Array"><c path="String"/></c></history>
		<pwd><c path="flash.display.DisplayObjectContainer"/></pwd>
		<tf><c path="flash.text.TextField"/></tf>
		<input><c path="flash.text.TextField"/></input>
		<vert><c path="haxegui.controls.Scrollbar"/></vert>
		<log public="1" line="208"><f a="e:?inf">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></log>
		<onKeyDown public="1" line="285"><f a="e">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyDown>
		<clear public="1" line="341"><f a=""><e path="Void"/></f></clear>
		<createInstance line="348"><f a="s:a">
	<c path="String"/>
	<c path="Array"><d/></c>
	<unknown/>
</f></createInstance>
		<getClass line="353"><f a="s">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></getClass>
		<new public="1" line="84">
			<f a="?parent:?x:?y">
				<c path="flash.display.DisplayObjectContainer"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 </haxe_doc>
		</new>
		<haxe_doc>
 * 
 * 
 * 
 * 
 </haxe_doc>
	</class>
	<class path="feffects.easing.Quad" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Quad.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" line="5" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" line="10" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" line="15" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<enum path="flash.ui.KeyLocation" params="" file="/usr/lib/haxe/std/flash9/ui/KeyLocation.hx">
		<STANDARD/>
		<RIGHT/>
		<NUM_PAD/>
		<LEFT/>
	</enum>
	<class path="flash.accessibility.AccessibilityImplementation" params="" file="/usr/lib/haxe/std/flash9/accessibility/AccessibilityImplementation.hx" extern="1">
		<errno public="1"><t path="UInt"/></errno>
		<stub public="1"><e path="Bool"/></stub>
		<accDoDefaultAction public="1"><f a="childID">
	<t path="UInt"/>
	<e path="Void"/>
</f></accDoDefaultAction>
		<accLocation public="1"><f a="childID">
	<t path="UInt"/>
	<d/>
</f></accLocation>
		<accSelect public="1"><f a="operation:childID">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></accSelect>
		<getChildIDArray public="1"><f a=""><c path="Array"><d/></c></f></getChildIDArray>
		<get_accDefaultAction public="1"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accDefaultAction>
		<get_accFocus public="1"><f a=""><t path="UInt"/></f></get_accFocus>
		<get_accName public="1"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accName>
		<get_accRole public="1"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accRole>
		<get_accSelection public="1"><f a=""><c path="Array"><d/></c></f></get_accSelection>
		<get_accState public="1"><f a="childID">
	<t path="UInt"/>
	<t path="UInt"/>
</f></get_accState>
		<get_accValue public="1"><f a="childID">
	<t path="UInt"/>
	<c path="String"/>
</f></get_accValue>
		<isLabeledBy public="1"><f a="labelBounds">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></isLabeledBy>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.text.TextLineMetrics" params="" file="/usr/lib/haxe/std/flash9/text/TextLineMetrics.hx" extern="1">
		<ascent public="1"><c path="Float"/></ascent>
		<descent public="1"><c path="Float"/></descent>
		<height public="1"><c path="Float"/></height>
		<leading public="1"><c path="Float"/></leading>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<new public="1"><f a="x:width:height:ascent:descent:leading">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastCell_hscript_Token" params="" file="/usr/lib/haxe/std/haxe/FastList.hx">
		<elt public="1"><e path="hscript.Token"/></elt>
		<next public="1"><c path="haxe.FastCell_hscript_Token"/></next>
		<new public="1" line="30"><f a="elt:next">
	<e path="hscript.Token"/>
	<c path="haxe.FastCell_hscript_Token"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.ApplicationDomain" params="" file="/usr/lib/haxe/std/flash9/system/ApplicationDomain.hx" extern="1">
		<currentDomain public="1" set="null" static="1"><c path="flash.system.ApplicationDomain"/></currentDomain>
		<parentDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></parentDomain>
		<getDefinition public="1"><f a="name">
	<c path="String"/>
	<d/>
</f></getDefinition>
		<hasDefinition public="1"><f a="name">
	<c path="String"/>
	<e path="Bool"/>
</f></hasDefinition>
		<new public="1"><f a="?parentDomain">
	<c path="flash.system.ApplicationDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.Lib" params="" file="/usr/lib/haxe/std/flash9/Lib.hx">
		<current public="1" static="1"><c path="flash.display.MovieClip"/></current>
		<getTimer public="1" line="31" static="1"><f a=""><c path="Int"/></f></getTimer>
		<eval public="1" line="35" static="1"><f a="path">
	<c path="String"/>
	<d/>
</f></eval>
		<getURL public="1" line="55" static="1"><f a="url:?target">
	<c path="flash.net.URLRequest"/>
	<c path="String"/>
	<e path="Void"/>
</f></getURL>
		<fscommand public="1" line="63" static="1"><f a="cmd:?param">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></fscommand>
		<trace public="1" line="67" static="1"><f a="arg">
	<d/>
	<e path="Void"/>
</f></trace>
		<attach public="1" line="71" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.display.MovieClip"/>
</f></attach>
		<as public="1" params="T" line="76" static="1"><f a="v:c">
	<d/>
	<c path="Class"><c path="as.T"/></c>
	<t path="Null"><c path="as.T"/></t>
</f></as>
	</class>
	<class path="flash.xml.XMLList" params="" file="/usr/lib/haxe/std/flash9/xml/XMLList.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<addNamespace public="1"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1"><f a=""><c path="Int"/></f></childIndex>
		<children public="1"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<copy public="1"><f a=""><c path="flash.xml.XMLList"/></f></copy>
		<descendants public="1"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1"><f a=""><e path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1"><f a="child1:child2">
	<d/>
	<d/>
	<e path="Void"/>
</f></insertChildAfter>
		<insertChildBefore public="1"><f a="child1:child2">
	<d/>
	<d/>
	<e path="Void"/>
</f></insertChildBefore>
		<length public="1"><f a=""><c path="Int"/></f></length>
		<localName public="1"><f a=""><d/></f></localName>
		<name public="1"><f a=""><d/></f></name>
		<namespace public="1"><f a="?prefix">
	<d/>
	<e path="Void"/>
</f></namespace>
		<namespaceDeclarations public="1"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1"><f a=""><c path="flash.xml.XMLList"/></f></normalize>
		<parent public="1"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setName public="1"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setNamespace public="1"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<text public="1"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toString public="1"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1"><f a=""><c path="flash.xml.XMLList"/></f></valueOf>
		<new public="1"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxegui.Utils" params="" file="./haxegui/Utils.hx">
		<print_r public="1" line="40" static="1">
			<f a="obj:?indent">
				<d/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 </haxe_doc>
		</print_r>
		<print_a public="1" line="51" static="1">
			<f a="obj:?indent">
				<d/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 </haxe_doc>
		</print_a>
		<print_mc public="1" line="94" static="1">
			<f a="obj:?indent">
				<c path="flash.display.DisplayObjectContainer"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 </haxe_doc>
		</print_mc>
	</class>
	<class path="feffects.easing.Expo" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Expo.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" line="5" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" line="10" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" line="15" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="haxegui.ColorPicker" params="" file="./haxegui/ColorPicker.hx">
		<extends path="haxegui.Window"/>
		<colSprite><c path="flash.display.Sprite"/></colSprite>
		<currentColor><t path="UInt"/></currentColor>
		<input><c path="haxegui.controls.Input"/></input>
		<onMouseUpImage public="1" line="259"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseUpImage>
		<onMouseMoveImage public="1" line="267"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseMoveImage>
		<updateColor public="1" line="298"><f a=""><e path="Void"/></f></updateColor>
		<updateInput public="1" line="323"><f a=""><e path="Void"/></f></updateInput>
		<new public="1" line="91">
			<f a="?parent:?x:?y">
				<c path="flash.display.DisplayObjectContainer"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 </haxe_doc>
		</new>
		<haxe_doc>
 * 
 * 
 * 
 * 
 </haxe_doc>
	</class>
	<class path="flash.accessibility.AccessibilityProperties" params="" file="/usr/lib/haxe/std/flash9/accessibility/AccessibilityProperties.hx" extern="1">
		<description public="1"><c path="String"/></description>
		<forceSimple public="1"><e path="Bool"/></forceSimple>
		<name public="1"><c path="String"/></name>
		<noAutoLabeling public="1"><e path="Bool"/></noAutoLabeling>
		<shortcut public="1"><c path="String"/></shortcut>
		<silent public="1"><e path="Bool"/></silent>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.net.URLRequestHeader" params="" file="/usr/lib/haxe/std/flash9/net/URLRequestHeader.hx" extern="1">
		<name public="1"><c path="String"/></name>
		<value public="1"><c path="String"/></value>
		<new public="1"><f a="?name:?value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Input" params="" file="/usr/lib/haxe/std/haxe/io/Input.hx">
		<bigEndian public="1" set="setEndian"><e path="Bool"/></bigEndian>
		<readByte public="1" line="35"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1" line="44"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<c path="Int"/>
</f></readBytes>
		<close public="1" line="65"><f a=""><e path="Void"/></f></close>
		<setEndian line="68"><f a="b">
	<e path="Bool"/>
	<e path="Bool"/>
</f></setEndian>
		<readAll public="1" line="75"><f a="?bufsize">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></readAll>
		<readFullBytes public="1" line="96"><f a="s:pos:len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></readFullBytes>
		<read public="1" line="104"><f a="nbytes">
	<c path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></read>
		<readUntil public="1" line="116"><f a="end">
	<c path="Int"/>
	<c path="String"/>
</f></readUntil>
		<readLine public="1" line="124"><f a=""><c path="String"/></f></readLine>
		<readFloat public="1" line="141"><f a=""><c path="Float"/></f></readFloat>
		<readDouble public="1" line="155"><f a=""><c path="Float"/></f></readDouble>
		<readInt8 public="1" line="169"><f a=""><c path="Int"/></f></readInt8>
		<readInt16 public="1" line="176"><f a=""><c path="Int"/></f></readInt16>
		<readUInt16 public="1" line="185"><f a=""><c path="Int"/></f></readUInt16>
		<readInt24 public="1" line="191"><f a=""><c path="Int"/></f></readInt24>
		<readUInt24 public="1" line="201"><f a=""><c path="Int"/></f></readUInt24>
		<readInt31 public="1" line="208"><f a=""><c path="Int"/></f></readInt31>
		<readUInt30 public="1" line="225"><f a=""><c path="Int"/></f></readUInt30>
		<readInt32 public="1" line="234"><f a=""><c path="haxe.Int32"/></f></readInt32>
		<readString public="1" line="242"><f a="len">
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<haxe_doc>
	An Input is an abstract reader. See other classes in the [haxe.io] package
	for several possible implementations.
</haxe_doc>
	</class>
	<class path="haxe.io.BytesInput" params="" file="/usr/lib/haxe/std/haxe/io/BytesInput.hx">
		<extends path="haxe.io.Input"/>
		<b><t path="haxe.io.BytesData"/></b>
		<new public="1" line="35"><f a="b:?pos:?len">
	<c path="haxe.io.Bytes"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.SecurityDomain" params="" file="/usr/lib/haxe/std/flash9/system/SecurityDomain.hx" extern="1"><currentDomain public="1" set="null" static="1"><c path="flash.system.SecurityDomain"/></currentDomain></class>
	<enum path="flash.display.PixelSnapping" params="" file="/usr/lib/haxe/std/flash9/display/PixelSnapping.hx">
		<NEVER/>
		<AUTO/>
		<ALWAYS/>
	</enum>
	<class path="haxegui.events.MenuEvent" params="" file="./haxegui/events/MenuEvent.hx">
		<extends path="flash.events.Event"/>
		<CHANGE static="1"><c path="String"/></CHANGE>
		<ITEM_CLICK public="1" line="25" static="1"><c path="String"/></ITEM_CLICK>
		<ITEM_ROLL_OUT static="1"><c path="String"/></ITEM_ROLL_OUT>
		<ITEM_ROLL_OVER static="1"><c path="String"/></ITEM_ROLL_OVER>
		<MENU_HIDE public="1" line="28" static="1"><c path="String"/></MENU_HIDE>
		<MENU_SHOW public="1" line="29" static="1"><c path="String"/></MENU_SHOW>
		<index><c path="Int"/></index>
		<item public="1"><d/></item>
		<label><c path="String"/></label>
		<menu public="1"><c path="haxegui.controls.Component"/></menu>
		<menuBar public="1"><c path="haxegui.controls.Component"/></menuBar>
		<new public="1" line="8"><f a="type:?bubbles:?cancelable:?menuBar:?menu:?item:?label:?index">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="flash.display.DisplayObject"/>
	<c path="haxegui.controls.Component"/>
	<c path="flash.display.DisplayObject"/>
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Int32" params="" file="/usr/lib/haxe/std/haxe/Int32.hx">
		<make public="1" line="30" static="1"><f a="a:b">
	<c path="Int"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></make>
		<ofInt public="1" line="38" static="1"><f a="x">
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ofInt>
		<toInt public="1" line="46" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toInt>
		<toNativeInt public="1" line="59" static="1"><f a="x">
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></toNativeInt>
		<add public="1" line="67" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></add>
		<sub public="1" line="75" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></sub>
		<mul public="1" line="83" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mul>
		<div public="1" line="91" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></div>
		<mod public="1" line="99" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></mod>
		<shl public="1" line="107" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shl>
		<shr public="1" line="115" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></shr>
		<ushr public="1" line="123" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="Int"/>
	<c path="haxe.Int32"/>
</f></ushr>
		<and public="1" line="131" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></and>
		<or public="1" line="139" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></or>
		<xor public="1" line="147" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></xor>
		<neg public="1" line="155" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></neg>
		<complement public="1" line="163" static="1"><f a="a">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
</f></complement>
		<compare public="1" line="171" static="1"><f a="a:b">
	<c path="haxe.Int32"/>
	<c path="haxe.Int32"/>
	<c path="Int"/>
</f></compare>
	</class>
	<class path="haxegui.events.MoveEvent" params="" file="./haxegui/events/MoveEvent.hx">
		<extends path="flash.events.Event"/>
		<MOVE public="1" line="17" static="1"><c path="String"/></MOVE>
		<relatedObject public="1"><c path="flash.display.InteractiveObject"/></relatedObject>
		<oldX public="1"><c path="Float"/></oldX>
		<oldY public="1"><c path="Float"/></oldY>
		<new public="1" line="5"><f a="type:?bubbles:?cancelable:?oldX:?oldY">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.System" params="" file="/usr/lib/haxe/std/flash9/system/System.hx" extern="1">
		<ime public="1" set="null" static="1"><c path="flash.system.IME"/></ime>
		<totalMemory public="1" set="null" static="1"><t path="UInt"/></totalMemory>
		<useCodePage public="1" static="1"><e path="Bool"/></useCodePage>
		<vmVersion public="1" set="null" static="1"><c path="String"/></vmVersion>
		<exit public="1" static="1"><f a="code">
	<t path="UInt"/>
	<e path="Void"/>
</f></exit>
		<gc public="1" static="1"><f a=""><e path="Void"/></f></gc>
		<pause public="1" static="1"><f a=""><e path="Void"/></f></pause>
		<resume public="1" static="1"><f a=""><e path="Void"/></f></resume>
		<setClipboard public="1" static="1"><f a="string">
	<c path="String"/>
	<e path="Void"/>
</f></setClipboard>
	</class>
	<class path="flash.net.URLLoader" params="" file="/usr/lib/haxe/std/flash9/net/URLLoader.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<bytesLoaded public="1"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1"><t path="UInt"/></bytesTotal>
		<data public="1"><d/></data>
		<dataFormat public="1"><e path="flash.net.URLLoaderDataFormat"/></dataFormat>
		<close public="1"><f a=""><e path="Void"/></f></close>
		<load public="1"><f a="request">
	<c path="flash.net.URLRequest"/>
	<e path="Void"/>
</f></load>
		<new public="1"><f a="?request">
	<c path="flash.net.URLRequest"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.Shape" params="" file="/usr/lib/haxe/std/flash9/display/Shape.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<graphics public="1" set="null"><c path="flash.display.Graphics"/></graphics>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="haxegui.StyleManager" params="" file="./haxegui/StyleManager.hx">
		<BACKGROUND public="1" line="31" static="1"><t path="UInt"/></BACKGROUND>
		<BUTTON_FACE public="1" line="32" static="1"><t path="UInt"/></BUTTON_FACE>
		<INPUT_BACK public="1" line="33" static="1"><t path="UInt"/></INPUT_BACK>
		<INPUT_TEXT public="1" line="34" static="1"><t path="UInt"/></INPUT_TEXT>
		<LABEL_TEXT public="1" line="35" static="1"><t path="UInt"/></LABEL_TEXT>
		<DROPSHADOW public="1" line="36" static="1"><t path="UInt"/></DROPSHADOW>
		<PANEL public="1" line="37" static="1"><t path="UInt"/></PANEL>
		<PROGRESS_BAR public="1" line="38" static="1"><t path="UInt"/></PROGRESS_BAR>
		<getTextFormat public="1" line="40" static="1"><f a="?size:?color:?align">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="flash.text.TextFormatAlign"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="ValueType" params="" file="/usr/lib/haxe/std/Type.hx" module="Type">
		<TUnknown/>
		<TObject/>
		<TNull/>
		<TInt/>
		<TFunction/>
		<TFloat/>
		<TEnum a="e"><c path="Enum"/></TEnum>
		<TClass a="c"><c path="Class"><d/></c></TClass>
		<TBool/>
		<haxe_doc>
	The diffent possible runtime types of a value.
	See [Type] for the haXe Reflection API.
</haxe_doc>
	</enum>
	<class path="Type" params="" file="/usr/lib/haxe/std/Type.hx">
		<getClass public="1" params="T" line="26" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<c path="Class"><c path="getClass.T"/></c>
			</f>
			<haxe_doc>
		Returns the class of a value or [null] if this value is not a Class instance.
	</haxe_doc>
		</getClass>
		<getEnum public="1" line="79" static="1">
			<f a="o">
				<d/>
				<c path="Enum"/>
			</f>
			<haxe_doc>
		Returns the enum of a value or [null] if this value is not an Enum instance.
	</haxe_doc>
		</getEnum>
		<getSuperClass public="1" line="119" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Returns the super-class of a class, or null if no super class.
	</haxe_doc>
		</getSuperClass>
		<getClassName public="1" line="142" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of a class.
	</haxe_doc>
		</getClassName>
		<getEnumName public="1" line="167" static="1">
			<f a="e">
				<c path="Enum"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the complete name of an enum.
	</haxe_doc>
		</getEnumName>
		<resolveClass public="1" line="184" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Class"><d/></c>
			</f>
			<haxe_doc>
		Evaluates a class from a name. The class must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" line="239" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Enum"/>
			</f>
			<haxe_doc>
		Evaluates an enum from a name. The enum must have been compiled
		to be accessible.
	</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" line="289" static="1">
			<f a="cl:args">
				<c path="Class"><c path="createInstance.T"/></c>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>
		Creates an instance of the given class with the list of constructor arguments.
	</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" line="335" static="1">
			<f a="cl">
				<c path="Class"><c path="createEmptyInstance.T"/></c>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>
		Similar to [Reflect.createInstance] excepts that the constructor is not called.
		This enables you to create an instance without any side-effect.
	</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" line="391" static="1">
			<f a="e:constr:?params">
				<c path="Enum"/>
				<c path="String"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Create an instance of an enum by using a constructor name and parameters.
	</haxe_doc>
		</createEnum>
		<describe line="410" static="1"><f a="t:fact">
	<d/>
	<e path="Bool"/>
	<c path="Array"><c path="String"/></c>
</f></describe>
		<getInstanceFields public="1" line="428" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of instance fields.
	</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" line="478" static="1">
			<f a="c">
				<c path="Class"><d/></c>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of a class static fields.
	</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" line="520" static="1">
			<f a="e">
				<c path="Enum"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns all the available constructor names for an enum.
	</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" line="541" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>
		Returns the runtime type of a value.
	</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" line="664" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Recursively compare two enums constructors and parameters.
	</haxe_doc>
		</enumEq>
		<enumConstructor public="1" line="721" static="1">
			<f a="e">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns the constructor of an enum
	</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" line="736" static="1">
			<f a="e">
				<d/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>
		Returns the parameters of an enum
	</haxe_doc>
		</enumParameters>
		<enumIndex public="1" line="756" static="1">
			<f a="e">
				<d/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the index of the constructor of an enum
	</haxe_doc>
		</enumIndex>
		<haxe_doc>
	The haXe Reflection API enables you to retreive informations about any value,
	Classes and Enums at runtime.
</haxe_doc>
	</class>
	<class path="haxegui.controls.Stepper" params="" file="./haxegui/controls/Stepper.hx">
		<extends path="haxegui.controls.Component"/>
		<up public="1"><c path="haxegui.controls.Button"/></up>
		<down public="1"><c path="haxegui.controls.Button"/></down>
		<back public="1"><c path="flash.display.Sprite"/></back>
		<tf public="1"><c path="flash.text.TextField"/></tf>
		<value public="1"><c path="Float"/></value>
		<step public="1"><c path="Float"/></step>
		<min public="1"><c path="Float"/></min>
		<max public="1"><c path="Float"/></max>
		<color><t path="UInt"/></color>
		<timer><c path="haxe.Timer"/></timer>
		<delta><c path="Float"/></delta>
		<init public="1" line="90">
			<f a="?initObj">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   * 
   * 
   * 
   * 
   </haxe_doc>
		</init>
		<onRollOver public="1" line="182">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onRollOver>
		<onRollOut public="1" line="198">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onRollOut>
		<onMouseDown line="209">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   *
   </haxe_doc>
		</onMouseDown>
		<onEnterFrame line="239"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onEnterFrame>
		<onMouseUp line="263"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseUp>
		<onChanged public="1" line="280"><f a="?e">
	<d/>
	<e path="Void"/>
</f></onChanged>
		<new public="1" line="73"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.display.Stage" params="" file="/usr/lib/haxe/std/flash9/display/Stage.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<align public="1"><e path="flash.display.StageAlign"/></align>
		<focus public="1"><c path="flash.display.InteractiveObject"/></focus>
		<frameRate public="1"><c path="Float"/></frameRate>
		<quality public="1"><e path="flash.display.StageQuality"/></quality>
		<scaleMode public="1"><e path="flash.display.StageScaleMode"/></scaleMode>
		<showDefaultContextMenu public="1"><e path="Bool"/></showDefaultContextMenu>
		<stageFocusRect public="1"><e path="Bool"/></stageFocusRect>
		<stageHeight public="1"><c path="Int"/></stageHeight>
		<stageWidth public="1"><c path="Int"/></stageWidth>
		<invalidate public="1"><f a=""><e path="Void"/></f></invalidate>
		<isFocusInaccessible public="1"><f a=""><e path="Bool"/></f></isFocusInaccessible>
		<displayState public="1"><e path="flash.display.StageDisplayState"/></displayState>
		<fullScreenHeight public="1" set="null"><t path="UInt"/></fullScreenHeight>
		<fullScreenSourceRect public="1"><c path="flash.geom.Rectangle"/></fullScreenSourceRect>
		<fullScreenWidth public="1" set="null"><t path="UInt"/></fullScreenWidth>
	</class>
	<class path="haxegui.Menubar" params="" file="./haxegui/Menubar.hx">
		<extends path="haxegui.controls.Component"/>
		<numMenus public="1"><c path="Int"/></numMenus>
		<color public="1"><t path="UInt"/></color>
		<_menu><c path="Int"/></_menu>
		<init public="1" line="76"><f a="?initObj">
	<d/>
	<e path="Void"/>
</f></init>
		<onResize public="1" line="193">
			<f a="e">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * 
     * 
     * 
     </haxe_doc>
		</onResize>
		<redraw public="1" line="222"><f a="?damage">
	<e path="Bool"/>
	<e path="Void"/>
</f></redraw>
		<onMouseOut line="255"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onMouseOut>
		<onMouseUp line="296"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseUp>
		<onMouseDown line="301"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseDown>
		<onMouseMove line="325"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseMove>
		<onRollOver line="343"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onRollOver>
		<onPopupClosed line="355"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onPopupClosed>
		<onKeyDown public="1" line="365"><f a="e">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyDown>
		<onChanged public="1" line="424"><f a="?oldmenu">
	<c path="Int"/>
	<e path="Void"/>
</f></onChanged>
		<openmenuByName line="470">
			<f a="name">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   * 
   </haxe_doc>
		</openmenuByName>
		<openMenuAt line="478">
			<f a="i">
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * 
     </haxe_doc>
		</openMenuAt>
		<new public="1" line="70"><f a="?parent:?name:?x:?y:?width">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * 
 * 
 * 
 </haxe_doc>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.filters.BitmapFilterType" params="" file="/usr/lib/haxe/std/flash9/filters/BitmapFilterType.hx">
		<OUTER/>
		<INNER/>
		<FULL/>
	</enum>
	<class path="EReg" params="" file="/usr/lib/haxe/std/EReg.hx">
		<r><d/></r>
		<result><c path="+Array"/></result>
		<match public="1" line="85">
			<f a="s">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the regular expression matches the String.
		Updates the internal state accordingly.
	</haxe_doc>
		</match>
		<matched public="1" line="125">
			<f a="n">
				<c path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Returns a matched group or throw an expection if there
		is no such group. If [n = 0], the whole matched substring
		is returned.
	</haxe_doc>
		</matched>
		<matchedLeft public="1" line="152">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was as the left of
		of the matched substring.
	</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" line="178">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the part of the string that was at the right of
		of the matched substring.
	</haxe_doc>
		</matchedRight>
		<matchedPos public="1" line="210">
			<f a=""><a>
	<pos><c path="Int"/></pos>
	<len><c path="Int"/></len>
</a></f>
			<haxe_doc>
		Returns the position of the matched substring within the
		original matched string.
	</haxe_doc>
		</matchedPos>
		<split public="1" line="230">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Split a string by using the regular expression to match
		the separators.
	</haxe_doc>
		</split>
		<replace public="1" line="273">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Replaces a pattern by another string. The [by] format can
		contains [$1] to [$9] that will correspond to groups matched
		while replacing. [$$] means the [$] character.
	</haxe_doc>
		</replace>
		<customReplace public="1" line="339">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>
		For each occurence of the pattern in the string [s], the function [f] is called and
		can return the string that needs to be replaced. All occurences are matched anyway,
		and setting the [g] flag might cause some incorrect behavior on some platforms.
	</haxe_doc>
		</customReplace>
		<new public="1" line="52">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new regular expression with pattern [r] and
		options [opt].
	</haxe_doc>
		</new>
		<haxe_doc>
	Regular expressions are a way to find regular patterns into
	Strings. Have a look at the tutorial on haXe website to learn
	how to use them.
</haxe_doc>
	</class>
	<class path="flash.FlashXml__" params="" file="/usr/lib/haxe/std/flash9/FlashXml__.hx">
		<enode line="30" static="1"><c path="EReg"/></enode>
		<ecdata line="31" static="1"><c path="EReg"/></ecdata>
		<edoctype line="32" static="1"><c path="EReg"/></edoctype>
		<eend line="33" static="1"><c path="EReg"/></eend>
		<epcdata line="34" static="1"><c path="EReg"/></epcdata>
		<ecomment line="35" static="1"><c path="EReg"/></ecomment>
		<eprolog line="36" static="1"><c path="EReg"/></eprolog>
		<eattribute line="38" static="1"><c path="EReg"/></eattribute>
		<eclose line="39" static="1"><c path="EReg"/></eclose>
		<ecdata_end line="40" static="1"><c path="EReg"/></ecdata_end>
		<edoctype_elt line="41" static="1"><c path="EReg"/></edoctype_elt>
		<ecomment_end line="42" static="1"><c path="EReg"/></ecomment_end>
		<Element public="1" static="1"><c path="String"/></Element>
		<PCData public="1" static="1"><c path="String"/></PCData>
		<CData public="1" static="1"><c path="String"/></CData>
		<Comment public="1" static="1"><c path="String"/></Comment>
		<DocType public="1" static="1"><c path="String"/></DocType>
		<Prolog public="1" static="1"><c path="String"/></Prolog>
		<Document public="1" static="1"><c path="String"/></Document>
		<parse public="1" line="63" static="1"><f a="str">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></parse>
		<createElement public="1" line="171" static="1"><f a="name">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createElement>
		<createPCData public="1" line="180" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createPCData>
		<createCData public="1" line="187" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createCData>
		<createComment public="1" line="194" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createComment>
		<createDocType public="1" line="201" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createDocType>
		<createProlog public="1" line="208" static="1"><f a="data">
	<c path="String"/>
	<c path="flash.FlashXml__"/>
</f></createProlog>
		<createDocument public="1" line="215" static="1"><f a=""><c path="flash.FlashXml__"/></f></createDocument>
		<nodeType public="1" set="null"><e path="XmlType"/></nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName"><c path="String"/></nodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue"><c path="String"/></nodeValue>
		<parent public="1" get="getParent" set="null"><c path="flash.FlashXml__"/></parent>
		<_nodeName><c path="String"/></_nodeName>
		<_nodeValue><c path="String"/></_nodeValue>
		<_attributes><c path="Hash"><c path="String"/></c></_attributes>
		<_children><c path="Array"><c path="flash.FlashXml__"/></c></_children>
		<_parent><c path="flash.FlashXml__"/></_parent>
		<getNodeName line="222"><f a=""><c path="String"/></f></getNodeName>
		<setNodeName line="228"><f a="n">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<getNodeValue line="234"><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue line="240"><f a="v">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<getParent line="246"><f a=""><c path="flash.FlashXml__"/></f></getParent>
		<get public="1" line="250"><f a="att">
	<c path="String"/>
	<c path="String"/>
</f></get>
		<set public="1" line="256"><f a="att:value">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></set>
		<remove public="1" line="262"><f a="att">
	<c path="String"/>
	<e path="Void"/>
</f></remove>
		<exists public="1" line="268"><f a="att">
	<c path="String"/>
	<e path="Bool"/>
</f></exists>
		<attributes public="1" line="274"><f a=""><t path="Iterator"><c path="String"/></t></f></attributes>
		<iterator public="1" line="280"><f a=""><a>
	<next><f a=""><c path="flash.FlashXml__"/></f></next>
	<hasNext><f a=""><e path="Bool"/></f></hasNext>
</a></f></iterator>
		<elements public="1" line="294"><f a=""><a>
	<next><f a=""><c path="flash.FlashXml__"/></f></next>
	<hasNext><f a=""><e path="Bool"/></f></hasNext>
</a></f></elements>
		<elementsNamed public="1" line="326"><f a="name">
	<c path="String"/>
	<a>
		<next><f a=""><c path="flash.FlashXml__"/></f></next>
		<hasNext><f a=""><e path="Bool"/></f></hasNext>
	</a>
</f></elementsNamed>
		<firstChild public="1" line="359"><f a=""><c path="flash.FlashXml__"/></f></firstChild>
		<firstElement public="1" line="364"><f a=""><c path="flash.FlashXml__"/></f></firstElement>
		<addChild public="1" line="377"><f a="x">
	<c path="flash.FlashXml__"/>
	<e path="Void"/>
</f></addChild>
		<removeChild public="1" line="384"><f a="x">
	<c path="flash.FlashXml__"/>
	<e path="Bool"/>
</f></removeChild>
		<insertChild public="1" line="392"><f a="x:pos">
	<c path="flash.FlashXml__"/>
	<c path="Int"/>
	<e path="Void"/>
</f></insertChild>
		<toString public="1" line="399"><f a=""><c path="String"/></f></toString>
		<new line="168"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Reflect" params="" file="/usr/lib/haxe/std/Reflect.hx">
		<hasField public="1" line="35" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if an object has a field set. This doesn't take into account the object prototype (class methods).
	</haxe_doc>
		</hasField>
		<field public="1" line="61" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Returns the field of an object, or null if [o] is not an object or doesn't have this field.
	</haxe_doc>
		</field>
		<setField public="1" line="87" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set an object field value.
	</haxe_doc>
		</setField>
		<callMethod public="1" line="105" static="1">
			<f a="o:func:args">
				<d/>
				<d/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>
		Call a method with the given object and arguments.
	</haxe_doc>
		</callMethod>
		<fields public="1" line="132" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>
		Returns the list of fields of an object, excluding its prototype (class methods).
	</haxe_doc>
		</fields>
		<isFunction public="1" line="207" static="1">
			<f a="f">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is a function or not.
	</haxe_doc>
		</isFunction>
		<compare public="1" params="T" line="228" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Generic comparison function, does not work for methods, see [compareMethods]
	</haxe_doc>
		</compare>
		<compareMethods public="1" line="240" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Compare two methods closures. Returns true if it's the same method of the same instance.
		Does not work on Neko platform.
	</haxe_doc>
		</compareMethods>
		<isObject public="1" line="272" static="1">
			<f a="v">
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value is an object or not.

	</haxe_doc>
		</isObject>
		<deleteField public="1" line="311" static="1">
			<f a="o:f">
				<d/>
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Delete an object field.
	</haxe_doc>
		</deleteField>
		<copy public="1" params="T" line="338" static="1">
			<f a="o">
				<c path="copy.T"/>
				<c path="copy.T"/>
			</f>
			<haxe_doc>
		Make a copy of the fields of an object.
	</haxe_doc>
		</copy>
		<makeVarArgs public="1" line="356" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>
		Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.
	</haxe_doc>
		</makeVarArgs>
		<haxe_doc>
	The Reflect API is a way to manipulate values dynamicly through an
	abstract interface in an untyped manner. Use with care.
</haxe_doc>
	</class>
	<class path="haxe.FastList_feffects_Tween" params="" file="/usr/lib/haxe/std/haxe/FastList.hx">
		<head public="1"><c path="haxe.FastCell_feffects_Tween"/></head>
		<add public="1" line="49">
			<f a="item">
				<c path="feffects.Tween"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the head of the list.
	</haxe_doc>
		</add>
		<first public="1" line="57">
			<f a=""><t path="Null"><c path="feffects.Tween"/></t></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<pop public="1" line="66">
			<f a=""><t path="Null"><c path="feffects.Tween"/></t></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" line="79">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<remove public="1" line="87">
			<f a="v">
				<c path="feffects.Tween"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" line="107">
			<f a=""><t path="Iterator"><c path="feffects.Tween"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" line="124">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<new public="1" line="43">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
	</class>
	<enum path="flash.display.StageDisplayState" params="" file="/usr/lib/haxe/std/flash9/display/StageDisplayState.hx">
		<NORMAL/>
		<FULL_SCREEN/>
	</enum>
	<class path="haxegui.controls.Button" params="" file="./haxegui/controls/Button.hx">
		<extends path="haxegui.controls.Component"/>
		<label public="1"><c path="haxegui.controls.Label"/></label>
		<fmt public="1"><c path="flash.text.TextFormat"/></fmt>
		<color public="1"><t path="UInt"/></color>
		<init public="1" line="89"><f a="?initObj">
	<d/>
	<e path="Void"/>
</f></init>
		<onFocusChanged public="1" line="173">
			<f a="e">
				<c path="flash.events.FocusEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onFocusChanged>
		<redraw public="1" line="183">
			<f a="?color">
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	</haxe_doc>
		</redraw>
		<onRollOver public="1" line="235">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onRollOver>
		<onRollOut public="1" line="282">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onRollOut>
		<onMouseDown public="1" line="308">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onMouseDown>
		<onMouseUp public="1" line="344">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onMouseUp>
		<onKeyDown public="1" line="391"><f a="e">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyDown>
		<new public="1" line="83"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.display.LoaderInfo" params="" file="/usr/lib/haxe/std/flash9/display/LoaderInfo.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<getLoaderInfoByDefinition public="1" static="1">
			<f a="object">
				<d/>
				<c path="flash.display.LoaderInfo"/>
			</f>
			<haxe_doc> new in FP 9.0.115 </haxe_doc>
		</getLoaderInfoByDefinition>
		<actionScriptVersion public="1" set="null"><e path="flash.display.ActionScriptVersion"/></actionScriptVersion>
		<applicationDomain public="1" set="null"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<bytes public="1" set="null">
			<c path="flash.utils.ByteArray"/>
			<haxe_doc> new in FP 9.0.115 </haxe_doc>
		</bytes>
		<bytesLoaded public="1" set="null"><t path="UInt"/></bytesLoaded>
		<bytesTotal public="1" set="null"><t path="UInt"/></bytesTotal>
		<childAllowsParent public="1" set="null"><e path="Bool"/></childAllowsParent>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentType public="1" set="null"><c path="String"/></contentType>
		<frameRate public="1" set="null"><c path="Float"/></frameRate>
		<height public="1" set="null"><c path="Int"/></height>
		<loader public="1" set="null"><c path="flash.display.Loader"/></loader>
		<loaderURL public="1" set="null"><c path="String"/></loaderURL>
		<parameters public="1" set="null"><d><c path="String"/></d></parameters>
		<parentAllowsChild public="1" set="null"><e path="Bool"/></parentAllowsChild>
		<sameDomain public="1" set="null"><e path="Bool"/></sameDomain>
		<sharedEvents public="1" set="null"><c path="flash.events.EventDispatcher"/></sharedEvents>
		<swfVersion public="1" set="null"><e path="flash.display.SWFVersion"/></swfVersion>
		<url public="1" set="null"><c path="String"/></url>
		<width public="1" set="null"><c path="Int"/></width>
	</class>
	<enum path="flash.display.SWFVersion" params="" file="/usr/lib/haxe/std/flash9/display/SWFVersion.hx">
		<FLASH9/>
		<FLASH8/>
		<FLASH7/>
		<FLASH6/>
		<FLASH5/>
		<FLASH4/>
		<FLASH3/>
		<FLASH2/>
		<FLASH1/>
	</enum>
	<enum path="flash.display.LineScaleMode" params="" file="/usr/lib/haxe/std/flash9/display/LineScaleMode.hx">
		<VERTICAL/>
		<NORMAL/>
		<NONE/>
		<HORIZONTAL/>
	</enum>
	<class path="flash.display.Graphics" params="" file="/usr/lib/haxe/std/flash9/display/Graphics.hx" extern="1">
		<beginBitmapFill public="1"><f a="bitmap:?matrix:?repeat:?smooth">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Matrix"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></beginBitmapFill>
		<beginFill public="1"><f a="color:?alpha">
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginFill>
		<beginGradientFill public="1"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></beginGradientFill>
		<clear public="1"><f a=""><e path="Void"/></f></clear>
		<curveTo public="1"><f a="controlX:controlY:anchorX:anchorY">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></curveTo>
		<drawCircle public="1"><f a="x:y:radius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawCircle>
		<drawEllipse public="1"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawEllipse>
		<drawRect public="1"><f a="x:y:width:height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRect>
		<drawRoundRect public="1"><f a="x:y:width:height:ellipseWidth:?ellipseHeight">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRect>
		<drawRoundRectComplex public="1"><f a="x:y:width:height:topLeftRadius:topRightRadius:bottomLeftRadius:bottomRightRadius">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></drawRoundRectComplex>
		<endFill public="1"><f a=""><e path="Void"/></f></endFill>
		<lineGradientStyle public="1"><f a="type:colors:alphas:ratios:?matrix:?spreadMethod:?interpolationMethod:?focalPointRatio">
	<e path="flash.display.GradientType"/>
	<c path="Array"><t path="UInt"/></c>
	<c path="Array"><d/></c>
	<c path="Array"><d/></c>
	<c path="flash.geom.Matrix"/>
	<e path="flash.display.SpreadMethod"/>
	<e path="flash.display.InterpolationMethod"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineGradientStyle>
		<lineStyle public="1"><f a="?thickness:?color:?alpha:?pixelHinting:?scaleMode:?caps:?joints:?miterLimit">
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="flash.display.LineScaleMode"/>
	<e path="flash.display.CapsStyle"/>
	<e path="flash.display.JointStyle"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineStyle>
		<lineTo public="1"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></lineTo>
		<moveTo public="1"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></moveTo>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Date" params="" file="/usr/lib/haxe/std/Date.hx" extern="1">
		<now public="1" static="1">
			<f a=""><c path="Date"/></f>
			<haxe_doc>
		Returns a Date representing the current local time.
	</haxe_doc>
		</now>
		<fromTime public="1" static="1">
			<f a="t">
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a timestamp [t] which is the number of
		milliseconds elapsed since 1st January 1970.
	</haxe_doc>
		</fromTime>
		<fromString public="1" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date from a formated string of one of the following formats :
		[YYYY-MM-DD hh:mm:ss] or [YYYY-MM-DD] or [hh:mm:ss]. The first two formats
		are expressed in local time, the third in UTC Epoch.
	</haxe_doc>
		</fromString>
		<getTime public="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns the timestamp of the date. It's the number of milliseconds
		elapsed since 1st January 1970. It might only have a per-second precision
		depending on the platforms.
	</haxe_doc>
		</getTime>
		<getHours public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the hours value of the date (0-23 range).
	</haxe_doc>
		</getHours>
		<getMinutes public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the minutes value of the date (0-59 range).
	</haxe_doc>
		</getMinutes>
		<getSeconds public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the seconds of the date (0-59 range).
	</haxe_doc>
		</getSeconds>
		<getFullYear public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the full year of the date.
	</haxe_doc>
		</getFullYear>
		<getMonth public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the month of the date (0-11 range).
	</haxe_doc>
		</getMonth>
		<getDate public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the day of the date (1-31 range).
	</haxe_doc>
		</getDate>
		<getDay public="1">
			<f a=""><c path="Int"/></f>
			<haxe_doc>
		Returns the week day of the date (0-6 range).
	</haxe_doc>
		</getDay>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a string representation for the Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See [DateTools.format] for
		other formating rules.
	</haxe_doc>
		</toString>
		<new public="1">
			<f a="year:month:day:hour:min:sec">
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Creates a new date object.
	</haxe_doc>
		</new>
		<haxe_doc>
	The Date class is used for date manipulation. There is some extra functions
	available in the [DateTools] class.
</haxe_doc>
	</class>
	<class path="haxegui.Stats" params="" file="./haxegui/Stats.hx">
		<extends path="haxegui.Window"/>
		<list><c path="haxegui.controls.UiList"/></list>
		<interval><c path="Int"/></interval>
		<frameCounter><c path="Int"/></frameCounter>
		<timer><c path="haxe.Timer"/></timer>
		<delta><c path="Float"/></delta>
		<maxFPS><c path="Float"/></maxFPS>
		<minFPS><c path="Float"/></minFPS>
		<avgFPS><c path="Array"><c path="Float"/></c></avgFPS>
		<update public="1" line="149">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
     *
     * 
     </haxe_doc>
		</update>
		<onEnterFrame public="1" line="191"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onEnterFrame>
		<new public="1" line="89">
			<f a="?parent:?x:?y">
				<c path="flash.display.DisplayObjectContainer"/>
				<c path="Float"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 </haxe_doc>
		</new>
		<haxe_doc>
 * 
 * 
 * 
 </haxe_doc>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="flash.display.BitmapData" params="" file="/usr/lib/haxe/std/flash9/display/BitmapData.hx" extern="1">
		<implements path="flash.display.IBitmapDrawable"/>
		<height public="1" set="null"><c path="Int"/></height>
		<rect public="1" set="null"><c path="flash.geom.Rectangle"/></rect>
		<transparent public="1" set="null"><e path="Bool"/></transparent>
		<width public="1" set="null"><c path="Int"/></width>
		<applyFilter public="1"><f a="sourceBitmapData:sourceRect:destPoint:filter">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.filters.BitmapFilter"/>
	<e path="Void"/>
</f></applyFilter>
		<clone public="1"><f a=""><c path="flash.display.BitmapData"/></f></clone>
		<colorTransform public="1"><f a="rect:colorTransform">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></colorTransform>
		<compare public="1"><f a="otherBitmapData">
	<c path="flash.display.BitmapData"/>
	<d/>
</f></compare>
		<copyChannel public="1"><f a="sourceBitmapData:sourceRect:destPoint:sourceChannel:destChannel">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></copyChannel>
		<copyPixels public="1"><f a="sourceBitmapData:sourceRect:destPoint:?alphaBitmapData:?alphaPoint:?mergeAlpha">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></copyPixels>
		<dispose public="1"><f a=""><e path="Void"/></f></dispose>
		<draw public="1"><f a="source:?matrix:?colorTransform:?blendMode:?clipRect:?smoothing">
	<c path="flash.display.IBitmapDrawable"/>
	<c path="flash.geom.Matrix"/>
	<c path="flash.geom.ColorTransform"/>
	<e path="flash.display.BlendMode"/>
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></draw>
		<fillRect public="1"><f a="rect:color">
	<c path="flash.geom.Rectangle"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></fillRect>
		<floodFill public="1"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></floodFill>
		<generateFilterRect public="1"><f a="sourceRect:filter">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.filters.BitmapFilter"/>
	<c path="flash.geom.Rectangle"/>
</f></generateFilterRect>
		<getColorBoundsRect public="1"><f a="mask:color:?findColor">
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="flash.geom.Rectangle"/>
</f></getColorBoundsRect>
		<getPixel public="1"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel>
		<getPixel32 public="1"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
</f></getPixel32>
		<getPixels public="1"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
</f></getPixels>
		<hitTest public="1"><f a="firstPoint:firstAlphaThreshold:secondObject:?secondBitmapDataPoint:?secondAlphaThreshold">
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<d/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<e path="Bool"/>
</f></hitTest>
		<lock public="1"><f a=""><e path="Void"/></f></lock>
		<merge public="1"><f a="sourceBitmapData:sourceRect:destPoint:redMultiplier:greenMultiplier:blueMultiplier:alphaMultiplier">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></merge>
		<noise public="1"><f a="randomSeed:?low:?high:?channelOptions:?grayScale">
	<c path="Int"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></noise>
		<paletteMap public="1"><f a="sourceBitmapData:sourceRect:destPoint:?redArray:?greenArray:?blueArray:?alphaArray">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<c path="Array"><c path="Int"/></c>
	<e path="Void"/>
</f></paletteMap>
		<perlinNoise public="1"><f a="baseX:baseY:numOctaves:randomSeed:stitch:fractalNoise:?channelOptions:?grayScale:?offsets">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Int"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<c path="Array"><c path="flash.geom.Point"/></c>
	<e path="Void"/>
</f></perlinNoise>
		<pixelDissolve public="1"><f a="sourceBitmapData:sourceRect:destPoint:?randomSeed:?numPixels:?fillColor">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<c path="Int"/>
</f></pixelDissolve>
		<scroll public="1"><f a="x:y">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></scroll>
		<setPixel public="1"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel>
		<setPixel32 public="1"><f a="x:y:color">
	<c path="Int"/>
	<c path="Int"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></setPixel32>
		<setPixels public="1"><f a="rect:inputByteArray">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.utils.ByteArray"/>
	<e path="Void"/>
</f></setPixels>
		<threshold public="1"><f a="sourceBitmapData:sourceRect:destPoint:operation:threshold:?color:?mask:?copySource">
	<c path="flash.display.BitmapData"/>
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Point"/>
	<c path="String"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Bool"/>
	<t path="UInt"/>
</f></threshold>
		<unlock public="1"><f a="?changeRect">
	<c path="flash.geom.Rectangle"/>
	<e path="Void"/>
</f></unlock>
		<new public="1"><f a="width:height:?transparent:?fillColor">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Bool"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.Eof" params="" file="/usr/lib/haxe/std/haxe/io/Eof.hx">
		<toString line="33"><f a=""><c path="String"/></f></toString>
		<new public="1" line="31"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
	This exception is raised when reading while data is no longer available in the [Input].
</haxe_doc>
	</class>
	<class path="flash.geom.Point" params="" file="/usr/lib/haxe/std/flash9/geom/Point.hx" extern="1">
		<distance public="1" static="1"><f a="pt1:pt2">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
</f></distance>
		<interpolate public="1" static="1"><f a="pt1:pt2:f">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></interpolate>
		<polar public="1" static="1"><f a="len:angle">
	<c path="Float"/>
	<c path="Float"/>
	<c path="flash.geom.Point"/>
</f></polar>
		<length public="1" set="null"><c path="Float"/></length>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<add public="1"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></add>
		<clone public="1"><f a=""><c path="flash.geom.Point"/></f></clone>
		<equals public="1"><f a="toCompare">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></equals>
		<normalize public="1"><f a="thickness">
	<c path="Float"/>
	<e path="Void"/>
</f></normalize>
		<offset public="1"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<subtract public="1"><f a="v">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></subtract>
		<toString public="1"><f a=""><c path="String"/></f></toString>
		<new public="1"><f a="?x:?y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.system.LoaderContext" params="" file="/usr/lib/haxe/std/flash9/system/LoaderContext.hx" extern="1">
		<applicationDomain public="1"><c path="flash.system.ApplicationDomain"/></applicationDomain>
		<checkPolicyFile public="1"><e path="Bool"/></checkPolicyFile>
		<securityDomain public="1"><c path="flash.system.SecurityDomain"/></securityDomain>
		<new public="1"><f a="?checkPolicyFile:?applicationDomain:?securityDomain">
	<e path="Bool"/>
	<c path="flash.system.ApplicationDomain"/>
	<c path="flash.system.SecurityDomain"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.filters.BevelFilter" params="" file="/usr/lib/haxe/std/flash9/filters/BevelFilter.hx" extern="1">
		<extends path="flash.filters.BitmapFilter"/>
		<angle public="1"><c path="Float"/></angle>
		<blurX public="1"><c path="Float"/></blurX>
		<blurY public="1"><c path="Float"/></blurY>
		<distance public="1"><c path="Float"/></distance>
		<highlightAlpha public="1"><c path="Float"/></highlightAlpha>
		<highlightColor public="1"><t path="UInt"/></highlightColor>
		<knockout public="1"><e path="Bool"/></knockout>
		<quality public="1"><c path="Int"/></quality>
		<shadowAlpha public="1"><c path="Float"/></shadowAlpha>
		<shadowColor public="1"><t path="UInt"/></shadowColor>
		<strength public="1"><c path="Float"/></strength>
		<type public="1"><e path="flash.filters.BitmapFilterType"/></type>
		<new public="1"><f a="?distance:?angle:?highlightColor:?highlightAlpha:?shadowColor:?shadowAlpha:?blurX:?blurY:?strength:?quality:?type:?knockout">
	<c path="Float"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<t path="UInt"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
	<e path="flash.filters.BitmapFilterType"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.filters.BitmapFilterQuality" params="" file="/usr/lib/haxe/std/flash9/filters/BitmapFilterQuality.hx" extern="1">
		<HIGH public="1" static="1"><c path="Int"/></HIGH>
		<LOW public="1" static="1"><c path="Int"/></LOW>
		<MEDIUM public="1" static="1"><c path="Int"/></MEDIUM>
	</class>
	<class path="haxegui.controls.CheckBox" params="" file="./haxegui/controls/CheckBox.hx">
		<extends path="haxegui.controls.Component"/>
		<checked public="1"><e path="Bool"/></checked>
		<label public="1"><c path="haxegui.controls.Label"/></label>
		<button public="1"><c path="flash.display.Sprite"/></button>
		<color public="1"><t path="UInt"/></color>
		<init public="1" line="76">
			<f a="?initObj">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   * 
   * 
   * 
   * 
   </haxe_doc>
		</init>
		<onDisabled public="1" line="139">
			<f a="e">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 </haxe_doc>
		</onDisabled>
		<onEnabled public="1" line="151">
			<f a="e">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 </haxe_doc>
		</onEnabled>
		<redraw public="1" line="163">
			<f a="?color">
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 *
	 * 
	 </haxe_doc>
		</redraw>
		<onRollOver public="1" line="235">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onRollOver>
		<onRollOut public="1" line="251">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onRollOut>
		<onMouseDown public="1" line="262">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onMouseDown>
		<onMouseUp public="1" line="278">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onMouseUp>
		<new public="1" line="64"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="StringBuf" params="" file="/usr/lib/haxe/std/StringBuf.hx">
		<add public="1" line="48">
			<f a="?x">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds the representation of any value to the string buffer.
	</haxe_doc>
		</add>
		<addSub public="1" line="61">
			<f a="s:pos:?len">
				<c path="String"/>
				<c path="Int"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a part of a string to the string buffer.
	</haxe_doc>
		</addSub>
		<addChar public="1" line="79">
			<f a="c">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a character to the string buffer.
	</haxe_doc>
		</addChar>
		<toString public="1" line="95">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns the content of the string buffer.
		The buffer is not emptied by this operation.
	</haxe_doc>
		</toString>
		<b><c path="String"/></b>
		<new public="1" line="35">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new string buffer.
	</haxe_doc>
		</new>
		<haxe_doc>
	A String buffer is an efficient way to build a big string by
	appending small elements together.
</haxe_doc>
	</class>
	<class path="flash.Error" params="" file="/usr/lib/haxe/std/flash9/Error.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<getErrorMessage public="1" static="1"><f a="index">
	<c path="Int"/>
	<c path="String"/>
</f></getErrorMessage>
		<throwError public="1" static="1"><f a="type:index:?p1:?p2:?p3:?p4:?p5">
	<c path="Class"><d/></c>
	<t path="UInt"/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
	<d/>
</f></throwError>
		<errorID public="1" set="null"><c path="Int"/></errorID>
		<message public="1"><d/></message>
		<name public="1"><d/></name>
		<getStackTrace public="1"><f a=""><c path="String"/></f></getStackTrace>
		<new public="1"><f a="?message:?id">
	<c path="String"/>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.display.Scene" params="" file="/usr/lib/haxe/std/flash9/display/Scene.hx" extern="1">
		<labels public="1" set="null"><c path="Array"><c path="flash.display.FrameLabel"/></c></labels>
		<name public="1" set="null"><c path="String"/></name>
		<numFrames public="1" set="null"><c path="Int"/></numFrames>
		<new public="1"><f a="name:labels:numFrames">
	<c path="String"/>
	<c path="Array"><c path="flash.display.FrameLabel"/></c>
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.Log" params="" file="/usr/lib/haxe/std/haxe/Log.hx">
		<trace public="1" line="29" static="1"><f a="v:?infos">
	<d/>
	<t path="haxe.PosInfos"/>
	<e path="Void"/>
</f></trace>
		<clear public="1" line="43" static="1"><f a=""><e path="Void"/></f></clear>
		<setColor public="1" line="52" static="1"><f a="rgb">
	<c path="Int"/>
	<e path="Void"/>
</f></setColor>
	</class>
	<enum path="hscript.Token" params="" file="/home/gershon/haxelib/hscript/1,4,6/hscript/Parser.hx" module="hscript.Parser">
		<TSemicolon/>
		<TQuestion/>
		<TPOpen/>
		<TPClose/>
		<TOp a="s"><c path="String"/></TOp>
		<TId a="s"><c path="String"/></TId>
		<TEof/>
		<TDoubleDot/>
		<TDot/>
		<TConst a="c"><e path="hscript.Const"/></TConst>
		<TComma/>
		<TBrOpen/>
		<TBrClose/>
		<TBkOpen/>
		<TBkClose/>
	</enum>
	<class path="hscript.Parser" params="" file="/home/gershon/haxelib/hscript/1,4,6/hscript/Parser.hx">
		<line public="1"><c path="Int"/></line>
		<opChars public="1"><c path="String"/></opChars>
		<identChars public="1"><c path="String"/></identChars>
		<opPriority public="1"><c path="Array"><c path="String"/></c></opPriority>
		<unopsPrefix public="1"><c path="Array"><c path="String"/></c></unopsPrefix>
		<unopsSuffix public="1"><c path="Array"><c path="String"/></c></unopsSuffix>
		<char><t path="Null"><c path="Int"/></t></char>
		<ops><c path="Array"><e path="Bool"/></c></ops>
		<idents><c path="Array"><e path="Bool"/></c></idents>
		<tokens><c path="haxe.FastList_hscript_Token"/></tokens>
		<parseString public="1" line="81"><f a="s">
	<c path="String"/>
	<e path="hscript.Expr"/>
</f></parseString>
		<parse public="1" line="86"><f a="s">
	<c path="haxe.io.Input"/>
	<e path="hscript.Expr"/>
</f></parse>
		<unexpected line="105"><f a="tk">
	<e path="hscript.Token"/>
	<d/>
</f></unexpected>
		<isBlock line="110"><f a="e">
	<e path="hscript.Expr"/>
	<e path="Bool"/>
</f></isBlock>
		<parseFullExpr line="125"><f a="s">
	<c path="haxe.io.Input"/>
	<e path="hscript.Expr"/>
</f></parseFullExpr>
		<parseExpr line="137"><f a="s">
	<c path="haxe.io.Input"/>
	<e path="hscript.Expr"/>
</f></parseExpr>
		<priority line="175"><f a="op">
	<c path="String"/>
	<c path="Int"/>
</f></priority>
		<makeUnop line="182"><f a="op:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></makeUnop>
		<makeBinop line="189"><f a="op:e1:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></makeBinop>
		<parseStructure line="200"><f a="s:id">
	<c path="haxe.io.Input"/>
	<c path="String"/>
	<e path="hscript.Expr"/>
</f></parseStructure>
		<parseExprNext line="333"><f a="s:e1">
	<c path="haxe.io.Input"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
</f></parseExprNext>
		<parseExprList line="373"><f a="s:etk">
	<c path="haxe.io.Input"/>
	<t path="Null"><e path="hscript.Token"/></t>
	<c path="Array"><e path="hscript.Expr"/></c>
</f></parseExprList>
		<readChar line="392"><f a="s">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
</f></readChar>
		<readString line="396"><f a="s:until">
	<c path="haxe.io.Input"/>
	<c path="Int"/>
	<c path="String"/>
</f></readString>
		<token line="431"><f a="s">
	<c path="haxe.io.Input"/>
	<t path="Null"><e path="hscript.Token"/></t>
</f></token>
		<tokenComment line="563"><f a="s:op:char">
	<c path="haxe.io.Input"/>
	<c path="String"/>
	<c path="Int"/>
	<t path="Null"><e path="hscript.Token"/></t>
</f></tokenComment>
		<constString line="596"><f a="c">
	<e path="hscript.Const"/>
	<c path="String"/>
</f></constString>
		<tokenString line="605"><f a="t">
	<e path="hscript.Token"/>
	<c path="String"/>
</f></tokenString>
		<new public="1" line="62"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="haxegui.controls.ScrollbarType" params="" file="./haxegui/controls/Scrollbar.hx" module="haxegui.controls.Scrollbar">
		<VERTICAL/>
		<HORIZONTAL/>
	</enum>
	<class path="haxegui.controls.Scrollbar" params="" file="./haxegui/controls/Scrollbar.hx">
		<extends path="haxegui.controls.Component"/>
		<color public="1"><t path="UInt"/></color>
		<horizontal><e path="Bool"/></horizontal>
		<frame><c path="flash.display.Sprite"/></frame>
		<handle><c path="flash.display.Sprite"/></handle>
		<up><c path="flash.display.Sprite"/></up>
		<down><c path="flash.display.Sprite"/></down>
		<scrollee public="1"><d/></scrollee>
		<scroll public="1"><c path="Float"/></scroll>
		<init public="1" line="102"><f a="?scrollee">
	<d/>
	<e path="Void"/>
</f></init>
		<onResize public="1" line="232"><f a="e">
	<d/>
	<e path="Void"/>
</f></onResize>
		<onRollOver public="1" line="284"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onRollOver>
		<onRollOut public="1" line="293"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onRollOut>
		<onMouseWheel public="1" line="309"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseWheel>
		<onMouseDown public="1" line="334">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * onMouseDown
	 * 
	 * 
	 </haxe_doc>
		</onMouseDown>
		<onEnterFrame public="1" line="411"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onEnterFrame>
		<onMouseUp public="1" line="428"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseUp>
		<onMouseMove public="1" line="439"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseMove>
		<adjust public="1" line="451">
			<f a="?e">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 * 
	 </haxe_doc>
		</adjust>
		<redrawHandle line="518">
			<f a="?color">
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 * 
	 </haxe_doc>
		</redrawHandle>
		<new public="1" line="90"><f a="?parent:?name:?x:?y:?horz">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="feffects.easing.Elastic" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Elastic.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" line="6" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" line="26" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" line="46" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="haxe.Serializer" params="" file="/usr/lib/haxe/std/haxe/Serializer.hx">
		<USE_CACHE public="1" line="34" static="1">
			<e path="Bool"/>
			<haxe_doc>
		If the values you are serializing can contain
		circular references or objects repetitions, you should
		set USE_CACHE to true to prevent infinite loops.
	</haxe_doc>
		</USE_CACHE>
		<USE_ENUM_INDEX public="1" line="40" static="1">
			<e path="Bool"/>
			<haxe_doc>
		Use constructor indexes for enums instead of names.
		This is less reliable but more compact.
	</haxe_doc>
		</USE_ENUM_INDEX>
		<BASE64 line="42" static="1"><c path="String"/></BASE64>
		<run public="1" line="400" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Serialize a single value and return the string.
	</haxe_doc>
		</run>
		<buf><c path="StringBuf"/></buf>
		<cache><c path="Array"><d/></c></cache>
		<shash><c path="Hash"><c path="Int"/></c></shash>
		<scount><c path="Int"/></scount>
		<useCache public="1"><e path="Bool"/></useCache>
		<useEnumIndex public="1"><e path="Bool"/></useEnumIndex>
		<toString public="1" line="60"><f a=""><c path="String"/></f></toString>
		<serializeString line="93"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></serializeString>
		<serializeRef line="112"><f a="v">
	<unknown/>
	<e path="Bool"/>
</f></serializeRef>
		<serializeClassFields line="135"><f a="v:c">
	<a><hasOwnProperty><f a="">
	<c path="String"/>
	<e path="Bool"/>
</f></hasOwnProperty></a>
	<c path="Class"><d/></c>
	<e path="Void"/>
</f></serializeClassFields>
		<serializeFields line="149"><f a="v">
	<unknown/>
	<e path="Void"/>
</f></serializeFields>
		<serialize public="1" line="157"><f a="v">
	<d/>
	<e path="Void"/>
</f></serialize>
		<serializeException public="1" line="381"><f a="e">
	<d/>
	<e path="Void"/>
</f></serializeException>
		<new public="1" line="51"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="haxe.io.BytesData" params="" file="/usr/lib/haxe/std/haxe/io/BytesData.hx"><c path="flash.utils.ByteArray"/></typedef>
	<typedef path="haxe.PosInfos" params="" file="/usr/lib/haxe/std/haxe/PosInfos.hx"><a>
	<methodName><c path="String"/></methodName>
	<lineNumber><c path="Int"/></lineNumber>
	<fileName><c path="String"/></fileName>
	<customParams><c path="Array"><d/></c></customParams>
	<className><c path="String"/></className>
</a></typedef>
	<class path="flash.geom.Matrix" params="" file="/usr/lib/haxe/std/flash9/geom/Matrix.hx" extern="1">
		<a public="1"><c path="Float"/></a>
		<b public="1"><c path="Float"/></b>
		<c public="1"><c path="Float"/></c>
		<d public="1"><c path="Float"/></d>
		<tx public="1"><c path="Float"/></tx>
		<ty public="1"><c path="Float"/></ty>
		<clone public="1"><f a=""><c path="flash.geom.Matrix"/></f></clone>
		<concat public="1"><f a="m">
	<c path="flash.geom.Matrix"/>
	<e path="Void"/>
</f></concat>
		<createBox public="1"><f a="scaleX:scaleY:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createBox>
		<createGradientBox public="1"><f a="width:height:?rotation:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></createGradientBox>
		<deltaTransformPoint public="1"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></deltaTransformPoint>
		<identity public="1"><f a=""><e path="Void"/></f></identity>
		<invert public="1"><f a=""><e path="Void"/></f></invert>
		<rotate public="1"><f a="angle">
	<c path="Float"/>
	<e path="Void"/>
</f></rotate>
		<scale public="1"><f a="sx:sy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></scale>
		<toString public="1"><f a=""><c path="String"/></f></toString>
		<transformPoint public="1"><f a="point">
	<c path="flash.geom.Point"/>
	<c path="flash.geom.Point"/>
</f></transformPoint>
		<translate public="1"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></translate>
		<new public="1"><f a="?a:?b:?c:?d:?tx:?ty">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.text.AntiAliasType" params="" file="/usr/lib/haxe/std/flash9/text/AntiAliasType.hx">
		<NORMAL/>
		<ADVANCED/>
	</enum>
	<class path="haxe.io.StringInput" params="" file="/usr/lib/haxe/std/haxe/io/StringInput.hx">
		<extends path="haxe.io.BytesInput"/>
		<new public="1" line="29"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxegui.controls.Label" params="" file="./haxegui/controls/Label.hx">
		<extends path="haxegui.controls.Component"/>
		<tf public="1"><c path="flash.text.TextField"/></tf>
		<init public="1" line="55">
			<f a="?initObj">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 * 
	 </haxe_doc>
		</init>
		<setText public="1" line="98"><f a="s">
	<c path="String"/>
	<e path="Void"/>
</f></setText>
		<new public="1" line="44"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastCell_feffects_Tween" params="" file="/usr/lib/haxe/std/haxe/FastList.hx">
		<elt public="1"><c path="feffects.Tween"/></elt>
		<next public="1"><c path="haxe.FastCell_feffects_Tween"/></next>
		<new public="1" line="30"><f a="elt:next">
	<c path="feffects.Tween"/>
	<c path="haxe.FastCell_feffects_Tween"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.utils.IDataOutput" params="" file="/usr/lib/haxe/std/flash9/utils/IDataOutput.hx" extern="1" interface="1">
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<writeBoolean public="1"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<writeByte public="1"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeDouble public="1"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeInt public="1"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeMultiByte public="1"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeObject public="1"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeShort public="1"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeUTF public="1"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
	</class>
	<class path="flash.media.SoundTransform" params="" file="/usr/lib/haxe/std/flash9/media/SoundTransform.hx" extern="1">
		<leftToLeft public="1"><c path="Float"/></leftToLeft>
		<leftToRight public="1"><c path="Float"/></leftToRight>
		<pan public="1"><c path="Float"/></pan>
		<rightToLeft public="1"><c path="Float"/></rightToLeft>
		<rightToRight public="1"><c path="Float"/></rightToRight>
		<volume public="1"><c path="Float"/></volume>
		<new public="1"><f a="?vol:?panning">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="hscript._Interp.Stop" params="" file="/home/gershon/haxelib/hscript/1,4,6/hscript/Interp.hx" private="1" module="hscript.Interp">
		<SReturn a="v"><d/></SReturn>
		<SContinue/>
		<SBreak/>
	</enum>
	<class path="hscript.Interp" params="" file="/home/gershon/haxelib/hscript/1,4,6/hscript/Interp.hx">
		<variables public="1"><c path="Hash"><d/></c></variables>
		<locals><c path="Hash"><a><r><d/></r></a></c></locals>
		<binops><c path="Hash"><f a=":">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<d/>
</f></c></binops>
		<declared><c path="Array"><a>
	<old><a><r><d/></r></a></old>
	<n><c path="String"/></n>
</a></c></declared>
		<initOps line="52"><f a=""><e path="Void"/></f></initOps>
		<assign line="89"><f a="e1:e2">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<d/>
</f></assign>
		<assignOp line="107"><f a="op:fop">
	<c path="String"/>
	<f a=":">
		<d/>
		<d/>
		<d/>
	</f>
	<e path="Void"/>
</f></assignOp>
		<evalAssignOp line="112"><f a="op:fop:e1:e2">
	<c path="String"/>
	<f a=":">
		<d/>
		<d/>
		<unknown/>
	</f>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<d/>
</f></evalAssignOp>
		<increment line="137"><f a="e:prefix:delta">
	<e path="hscript.Expr"/>
	<e path="Bool"/>
	<c path="Int"/>
	<d/>
</f></increment>
		<execute public="1" line="172"><f a="expr">
	<e path="hscript.Expr"/>
	<d/>
</f></execute>
		<exprReturn line="177"><f a="e">
	<e path="hscript.Expr"/>
	<d/>
</f></exprReturn>
		<duplicate params="T" line="190"><f a="h">
	<c path="Hash"><c path="duplicate.T"/></c>
	<c path="Hash"><t path="Null"><c path="duplicate.T"/></t></c>
</f></duplicate>
		<restore line="197"><f a="old">
	<c path="Int"/>
	<e path="Void"/>
</f></restore>
		<expr public="1" line="204"><f a="e">
	<e path="hscript.Expr"/>
	<d/>
</f></expr>
		<whileLoop line="348"><f a="econd:e">
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<e path="Void"/>
</f></whileLoop>
		<makeIterator line="364"><f a="v">
	<d/>
	<t path="Iterator"><d/></t>
</f></makeIterator>
		<forLoop line="374"><f a="n:it:e">
	<c path="String"/>
	<e path="hscript.Expr"/>
	<e path="hscript.Expr"/>
	<e path="Void"/>
</f></forLoop>
		<get line="393"><f a="o:f">
	<d/>
	<c path="String"/>
	<d/>
</f></get>
		<set line="398"><f a="o:f:v">
	<d/>
	<c path="String"/>
	<d/>
	<d/>
</f></set>
		<call line="404"><f a="o:f:args">
	<d/>
	<d/>
	<c path="Array"><d/></c>
	<d/>
</f></call>
		<cnew line="408"><f a="cl:args">
	<c path="String"/>
	<c path="Array"><d/></c>
	<d/>
</f></cnew>
		<new public="1" line="41"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="Math" params="" file="/usr/lib/haxe/std/Math.hx" extern="1">
		<PI public="1" set="null" static="1"><c path="Float"/></PI>
		<NaN public="1" set="null" static="1"><c path="Float"/></NaN>
		<NEGATIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1"><c path="Float"/></POSITIVE_INFINITY>
		<abs public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></abs>
		<min public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></min>
		<max public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></max>
		<sin public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></sin>
		<cos public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></cos>
		<atan2 public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></atan2>
		<tan public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></tan>
		<exp public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></exp>
		<log public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></log>
		<sqrt public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></sqrt>
		<round public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></round>
		<floor public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></floor>
		<ceil public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Int"/>
</f></ceil>
		<atan public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></atan>
		<asin public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></asin>
		<acos public="1" static="1"><f a="value">
	<c path="Float"/>
	<c path="Float"/>
</f></acos>
		<pow public="1" static="1"><f a="value1:value2">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></pow>
		<random public="1" static="1"><f a=""><c path="Float"/></f></random>
		<isFinite public="1" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isFinite>
		<isNaN public="1" static="1"><f a="f">
	<c path="Float"/>
	<e path="Bool"/>
</f></isNaN>
		<haxe_doc>
	This class defines mathematical functions and constants.
</haxe_doc>
	</class>
	<enum path="haxegui.WindowType" params="" file="./haxegui/Window.hx" module="haxegui.Window">
		<NORMAL/>
		<MODAL/>
		<ALWAYS_ON_TOP/>
	</enum>
	<class path="haxegui.Titlebar" params="" file="./haxegui/Window.hx" module="haxegui.Window">
		<extends path="flash.display.Sprite"/>
		<title public="1"><c path="flash.text.TextField"/></title>
		<closeButton public="1"><c path="haxegui.controls.Component"/></closeButton>
		<minimizeButton public="1"><c path="haxegui.controls.Component"/></minimizeButton>
		<redraw public="1" line="158">
			<f a="?color:?w">
				<c path="Int"/>
				<c path="Float"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * 
     * 
     </haxe_doc>
		</redraw>
		<onRollOver public="1" line="240"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onRollOver>
		<onRollOut public="1" line="245"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onRollOut>
		<onMouseUp public="1" line="250"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseUp>
		<new public="1" line="87"><f a="?w">
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc><![CDATA[
 * 
 * Titlebar class
 * 
 * @author <gershon@goosemoose.com>
 * @version 0.1
 ]]></haxe_doc>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="Std" params="" file="/usr/lib/haxe/std/Std.hx">
		<is public="1" line="34" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if a value v is of the type t.
	</haxe_doc>
		</is>
		<string public="1" line="54" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Convert any value to a String
	</haxe_doc>
		</string>
		<int public="1" line="74" static="1">
			<f a="x">
				<c path="Float"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Convert a Float to an Int, rounded down.
	</haxe_doc>
		</int>
		<parseInt public="1" line="88" static="1">
			<f a="x">
				<c path="String"/>
				<t path="Null"><c path="Int"/></t>
			</f>
			<haxe_doc>
		Convert a String to an Int, parsing different possible representations. Returns [null] if could not be parsed.
	</haxe_doc>
		</parseInt>
		<parseFloat public="1" line="129" static="1">
			<f a="x">
				<c path="String"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a String to a Float, parsing different possible reprensations.
	</haxe_doc>
		</parseFloat>
		<random public="1" line="151" static="1">
			<f a="x">
				<c path="Int"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Return a random integer between 0 included and x excluded.
	</haxe_doc>
		</random>
		<haxe_doc>
	The Std class provides standard methods for manipulating basic types.
</haxe_doc>
	</class>
	<class path="haxe.Unserializer" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx">
		<DEFAULT_RESOLVER public="1" line="34" static="1"><t path="haxe.TypeResolver"/></DEFAULT_RESOLVER>
		<BASE64 line="36" static="1"><c path="String"/></BASE64>
		<CODES line="39" static="1"><c path="flash.utils.ByteArray"/></CODES>
		<initCodes line="41" static="1"><f a=""><c path="flash.utils.ByteArray"/></f></initCodes>
		<run public="1" line="350" static="1">
			<f a="v">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>
		Unserialize a single value and return it.
	</haxe_doc>
		</run>
		<buf><c path="String"/></buf>
		<pos><c path="Int"/></pos>
		<length><c path="Int"/></length>
		<cache><c path="Array"><d/></c></cache>
		<scache><c path="Array"><c path="String"/></c></scache>
		<resolver><t path="haxe.TypeResolver"/></resolver>
		<setResolver public="1" line="76"><f a="r">
	<t path="haxe.TypeResolver"/>
	<e path="Void"/>
</f></setResolver>
		<get line="86"><f a="p">
	<c path="Int"/>
	<c path="Int"/>
</f></get>
		<readDigits line="96"><f a=""><c path="Int"/></f></readDigits>
		<unserializeObject line="129"><f a="o">
	<a/>
	<e path="Void"/>
</f></unserializeObject>
		<unserializeEnum line="144"><f a="edecl:tag">
	<c path="Enum"/>
	<c path="String"/>
	<unknown/>
</f></unserializeEnum>
		<unserialize public="1" line="165"><f a=""><d/></f></unserialize>
		<new public="1" line="64"><f a="buf">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxegui.XmlDeserializer" params="" file="./haxegui/XmlDeserializer.hx">
		<extends path="haxe.Unserializer"/>
		<xml public="1"><c path="Xml"/></xml>
		<getNode public="1" line="58"><f a="node:?parent">
	<c path="Xml"/>
	<d/>
	<d/>
</f></getNode>
		<getScript public="1" line="147"><f a="node">
	<c path="Xml"/>
	<d/>
</f></getScript>
		<deserialize public="1" line="207">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * 
	 * 
	 * 
	 </haxe_doc>
		</deserialize>
		<createInstance line="223">
			<f a="s:a">
				<c path="String"/>
				<c path="Array"><d/></c>
				<unknown/>
			</f>
			<haxe_doc>
	 *  10x to filt3rek:
	 * 
	 *  http://filt3r.free.fr/index.php/2008/07/23/59-hscript
	 * 
	 </haxe_doc>
		</createInstance>
		<getClass line="228"><f a="s">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></getClass>
		<new public="1" line="50"><f a="?xml">
	<c path="Xml"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.ActionScriptVersion" params="" file="/usr/lib/haxe/std/flash9/display/ActionScriptVersion.hx">
		<ACTIONSCRIPT3/>
		<ACTIONSCRIPT2/>
	</enum>
	<class path="haxe.Timer" params="" file="/usr/lib/haxe/std/haxe/Timer.hx">
		<delay public="1" line="76" static="1"><f a="f:time_ms">
	<f a=""><e path="Void"/></f>
	<c path="Int"/>
	<e path="Void"/>
</f></delay>
		<stamp public="1" line="89" static="1">
			<f a=""><c path="Float"/></f>
			<haxe_doc>
		Returns a timestamp, in seconds
	</haxe_doc>
		</stamp>
		<id><t path="Null"><c path="Int"/></t></id>
		<stop public="1" line="52"><f a=""><e path="Void"/></f></stop>
		<run public="1" line="73"><f a=""><e path="Void"/></f></run>
		<new public="1" line="38"><f a="time_ms">
	<c path="Int"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.geom.Rectangle" params="" file="/usr/lib/haxe/std/flash9/geom/Rectangle.hx" extern="1">
		<bottom public="1"><c path="Float"/></bottom>
		<bottomRight public="1"><c path="flash.geom.Point"/></bottomRight>
		<height public="1"><c path="Float"/></height>
		<left public="1"><c path="Float"/></left>
		<right public="1"><c path="Float"/></right>
		<size public="1"><c path="flash.geom.Point"/></size>
		<top public="1"><c path="Float"/></top>
		<topLeft public="1"><c path="flash.geom.Point"/></topLeft>
		<width public="1"><c path="Float"/></width>
		<x public="1"><c path="Float"/></x>
		<y public="1"><c path="Float"/></y>
		<clone public="1"><f a=""><c path="flash.geom.Rectangle"/></f></clone>
		<contains public="1"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Bool"/>
</f></contains>
		<containsPoint public="1"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Bool"/>
</f></containsPoint>
		<containsRect public="1"><f a="rect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></containsRect>
		<equals public="1"><f a="toCompare">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></equals>
		<inflate public="1"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inflate>
		<inflatePoint public="1"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></inflatePoint>
		<intersection public="1"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></intersection>
		<intersects public="1"><f a="toIntersect">
	<c path="flash.geom.Rectangle"/>
	<e path="Bool"/>
</f></intersects>
		<isEmpty public="1"><f a=""><e path="Bool"/></f></isEmpty>
		<offset public="1"><f a="dx:dy">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></offset>
		<offsetPoint public="1"><f a="point">
	<c path="flash.geom.Point"/>
	<e path="Void"/>
</f></offsetPoint>
		<setEmpty public="1"><f a=""><e path="Void"/></f></setEmpty>
		<toString public="1"><f a=""><c path="String"/></f></toString>
		<union public="1"><f a="toUnion">
	<c path="flash.geom.Rectangle"/>
	<c path="flash.geom.Rectangle"/>
</f></union>
		<new public="1"><f a="?x:?y:?width:?height">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxegui.Toolbar" params="" file="./haxegui/Toolbar.hx">
		<extends path="haxegui.controls.Component"/>
		<color public="1"><t path="UInt"/></color>
		<handle public="1"><c path="flash.display.Sprite"/></handle>
		<init public="1" line="65">
			<f a="?initObj">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
    * 
    * Initialize a new window
    * 
    * @param initObj Dynamic object containing attributes
    * 
    * 
    </haxe_doc>
		</init>
		<onResize public="1" line="110">
			<f a="e">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * 
     * 
     * 
     </haxe_doc>
		</onResize>
		<redraw public="1" line="145">
			<f a="?damage">
				<e path="Bool"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   * 
   * 
   </haxe_doc>
		</redraw>
		<new public="1" line="51"><f a="?parent:?name:?x:?y:?width:?height">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<class path="haxe.FastCell" params="T" file="/usr/lib/haxe/std/haxe/FastList.hx" module="haxe.FastList">
		<elt public="1"><c path="haxe.FastCell.T"/></elt>
		<next public="1"><c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c></next>
		<new public="1" line="30"><f a="elt:next">
	<c path="haxe.FastCell.T"/>
	<c path="haxe.FastCell"><c path="haxe.FastCell.T"/></c>
	<e path="Void"/>
</f></new>
	</class>
	<class path="haxe.FastList" params="T" file="/usr/lib/haxe/std/haxe/FastList.hx">
		<head public="1"><c path="haxe.FastCell"><c path="haxe.FastList.T"/></c></head>
		<add public="1" line="49">
			<f a="item">
				<c path="haxe.FastList.T"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Add an element at the head of the list.
	</haxe_doc>
		</add>
		<first public="1" line="57">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>
		Returns the first element of the list, or null
		if the list is empty.
	</haxe_doc>
		</first>
		<pop public="1" line="66">
			<f a=""><t path="Null"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>
		Removes the first element of the list and
		returns it or simply returns null if the
		list is empty.
	</haxe_doc>
		</pop>
		<isEmpty public="1" line="79">
			<f a=""><e path="Bool"/></f>
			<haxe_doc>
		Tells if a list is empty.
	</haxe_doc>
		</isEmpty>
		<remove public="1" line="87">
			<f a="v">
				<c path="haxe.FastList.T"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Remove the first element that is [== v] from the list.
		Returns [true] if an element was removed, [false] otherwise.
	</haxe_doc>
		</remove>
		<iterator public="1" line="107">
			<f a=""><t path="Iterator"><c path="haxe.FastList.T"/></t></f>
			<haxe_doc>
		Returns an iterator on the elements of the list.
	</haxe_doc>
		</iterator>
		<toString public="1" line="124">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a displayable representation of the String.
	</haxe_doc>
		</toString>
		<new public="1" line="43">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
		Creates a new empty list.
	</haxe_doc>
		</new>
		<haxe_doc>
	A linked-list of elements. A different class is created for each container used in platforms where it matters
</haxe_doc>
	</class>
	<class path="flash.events.TextEvent" params="" file="/usr/lib/haxe/std/flash9/events/TextEvent.hx" extern="1">
		<extends path="flash.events.Event"/>
		<LINK public="1" static="1"><c path="String"/></LINK>
		<TEXT_INPUT public="1" static="1"><c path="String"/></TEXT_INPUT>
		<text public="1"><c path="String"/></text>
		<new public="1"><f a="type:?bubbles:?cancelable:?text">
	<c path="String"/>
	<e path="Bool"/>
	<e path="Bool"/>
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.display.SpreadMethod" params="" file="/usr/lib/haxe/std/flash9/display/SpreadMethod.hx">
		<REPEAT/>
		<REFLECT/>
		<PAD/>
	</enum>
	<class path="haxegui.WindowManager" params="" file="./haxegui/WindowManager.hx">
		<extends path="flash.events.EventDispatcher"/>
		<_instance line="47" static="1"><c path="haxegui.WindowManager"/></_instance>
		<getInstance public="1" line="51" static="1"><f a=""><c path="haxegui.WindowManager"/></f></getInstance>
		<numWindows public="1"><t path="UInt"/></numWindows>
		<listeners public="1"><c path="Array"><c path="haxegui.ITraceListener"/></c></listeners>
		<windows public="1"><c path="IntHash"><c path="haxegui.Window"/></c></windows>
		<addWindow public="1" line="76"><f a="?parent">
	<d/>
	<c path="haxegui.Window"/>
</f></addWindow>
		<proxy public="1" line="96"><f a="e">
	<d/>
	<e path="Void"/>
</f></proxy>
		<new public="1" line="62"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.utils.Endian" params="" file="/usr/lib/haxe/std/flash9/utils/Endian.hx">
		<LITTLE_ENDIAN/>
		<BIG_ENDIAN/>
	</enum>
	<enum path="Void" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes"><haxe_doc>
	The standard Void type. Only [null] values can be of the type [Void].
</haxe_doc></enum>
	<class path="Float" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	The standard Float type, this is a double-precision IEEE 64bit float.
</haxe_doc></class>
	<class path="Int" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1">
		<extends path="Float"/>
		<haxe_doc>
	The standard Int type. Its precision depends on the platform.
</haxe_doc>
	</class>
	<typedef path="UInt" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Int"/>
		<haxe_doc>
	The unsigned Int type is only defined for Flash9. It's currently
	handled the same as a normal Int.
</haxe_doc>
	</typedef>
	<typedef path="Null" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>
	[Null] can be useful in two cases. In order to document some methods
	that accepts or can return a [null] value, or for the Flash9 compiler and AS3
	generator to distinguish between base values that can be null and others that
	can't.
</haxe_doc>
	</typedef>
	<enum path="Bool" params="" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<true/>
		<false/>
		<haxe_doc>
	The standard Boolean type is represented as an enum with two choices.
</haxe_doc>
	</enum>
	<class path="Dynamic" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1"><haxe_doc>
	Dynamic is an internal compiler type which has special behavior.
	See the haXe language reference for more informations.
</haxe_doc></class>
	<typedef path="Iterator" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next><f a=""><c path="Iterator.T"/></f></next>
			<hasNext><f a=""><e path="Bool"/></f></hasNext>
		</a>
		<haxe_doc>
	An Iterator is a structure that permits to list a given container
	values. It can be used by your own data structures. See the haXe
	documentation for more informations.
</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>
	An Iterable is a data structure which has an iterator() method.
	See [Lambda] for generic functions on iterable structures.
</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/lib/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>
	ArrayAccess is used to indicate a class that can be accessed using brackets.
	The type parameter represent the type of the elements stored.
</haxe_doc></class>
	<enum path="flash.events.EventPhase" params="" file="/usr/lib/haxe/std/flash9/events/EventPhase.hx">
		<CAPTURING_PHASE/>
		<BUBBLING_PHASE/>
		<AT_TARGET/>
	</enum>
	<class path="flash.display.Bitmap" params="" file="/usr/lib/haxe/std/flash9/display/Bitmap.hx" extern="1">
		<extends path="flash.display.DisplayObject"/>
		<bitmapData public="1"><c path="flash.display.BitmapData"/></bitmapData>
		<pixelSnapping public="1"><e path="flash.display.PixelSnapping"/></pixelSnapping>
		<smoothing public="1"><e path="Bool"/></smoothing>
		<new public="1"><f a="?bitmapData:?pixelSnapping:?smoothing">
	<c path="flash.display.BitmapData"/>
	<e path="flash.display.PixelSnapping"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></new>
	</class>
	<enum path="flash.system.IMEConversionMode" params="" file="/usr/lib/haxe/std/flash9/system/IMEConversionMode.hx">
		<UNKNOWN/>
		<KOREAN/>
		<JAPANESE_KATAKANA_HALF/>
		<JAPANESE_KATAKANA_FULL/>
		<JAPANESE_HIRAGANA/>
		<CHINESE/>
		<ALPHANUMERIC_HALF/>
		<ALPHANUMERIC_FULL/>
	</enum>
	<class path="haxegui.PopupMenu" params="" file="./haxegui/PopupMenu.hx">
		<extends path="haxegui.controls.Component"/>
		<_instance line="82" static="1"><c path="haxegui.PopupMenu"/></_instance>
		<getInstance public="1" line="90" static="1"><f a=""><c path="haxegui.PopupMenu"/></f></getInstance>
		<items><t path="UInt"/></items>
		<_item><t path="UInt"/></_item>
		<color public="1"><t path="UInt"/></color>
		<init public="1" line="103"><f a="parent:x:y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></init>
		<draw public="1" line="220"><f a=""><e path="Void"/></f></draw>
		<close public="1" line="245"><f a="?e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></close>
		<onMouseOut line="270"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseOut>
		<onRollOver line="275"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onRollOver>
		<onRollOut public="1" line="297"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onRollOut>
		<onMouseDown public="1" line="314">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   * 
   </haxe_doc>
		</onMouseDown>
		<onKeyDown public="1" line="322"><f a="e">
	<c path="flash.events.KeyboardEvent"/>
	<e path="Void"/>
</f></onKeyDown>
		<numItems public="1" line="342"><f a=""><t path="UInt"/></f></numItems>
		<nextItem public="1" line="346"><f a=""><e path="Void"/></f></nextItem>
		<prevItem public="1" line="352"><f a=""><e path="Void"/></f></prevItem>
		<getItem public="1" line="358"><f a=""><e path="Void"/></f></getItem>
		<onChanged public="1" line="362"><f a=""><e path="Void"/></f></onChanged>
		<new line="85"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 *
 * 
 * 
 * 
 </haxe_doc>
	</class>
	<enum path="flash.text.TextFieldType" params="" file="/usr/lib/haxe/std/flash9/text/TextFieldType.hx">
		<INPUT/>
		<DYNAMIC/>
	</enum>
	<class path="flash.utils.IDataInput" params="" file="/usr/lib/haxe/std/flash9/utils/IDataInput.hx" extern="1" interface="1">
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<readBoolean public="1"><f a=""><e path="Bool"/></f></readBoolean>
		<readByte public="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readDouble public="1"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1"><f a=""><c path="Float"/></f></readFloat>
		<readInt public="1"><f a=""><c path="Int"/></f></readInt>
		<readMultiByte public="1"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1"><f a=""><d/></f></readObject>
		<readShort public="1"><f a=""><c path="Int"/></f></readShort>
		<readUTF public="1"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1"><f a=""><t path="UInt"/></f></readUnsignedShort>
	</class>
	<class path="feffects.easing.Back" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Back.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" line="6" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" line="14" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" line="22" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="flash.xml.XML" params="" file="/usr/lib/haxe/std/flash9/xml/XML.hx" extern="1">
		<length public="1" static="1"><c path="Int"/></length>
		<ignoreComments public="1" static="1"><e path="Bool"/></ignoreComments>
		<ignoreProcessingInstructions public="1" static="1"><e path="Bool"/></ignoreProcessingInstructions>
		<ignoreWhitespace public="1" static="1"><e path="Bool"/></ignoreWhitespace>
		<prettyIndent public="1" static="1"><c path="Int"/></prettyIndent>
		<prettyPrinting public="1" static="1"><e path="Bool"/></prettyPrinting>
		<defaultSettings public="1" static="1"><f a=""><d/></f></defaultSettings>
		<setSettings public="1" static="1"><f a="?o">
	<d/>
	<e path="Void"/>
</f></setSettings>
		<settings public="1" static="1"><f a=""><d/></f></settings>
		<addNamespace public="1"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></addNamespace>
		<appendChild public="1"><f a="child">
	<d/>
	<c path="flash.xml.XML"/>
</f></appendChild>
		<attribute public="1"><f a="arg">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></attribute>
		<attributes public="1"><f a=""><c path="flash.xml.XMLList"/></f></attributes>
		<child public="1"><f a="propertyName">
	<d/>
	<c path="flash.xml.XMLList"/>
</f></child>
		<childIndex public="1"><f a=""><c path="Int"/></f></childIndex>
		<children public="1"><f a=""><c path="flash.xml.XMLList"/></f></children>
		<comments public="1"><f a=""><c path="flash.xml.XMLList"/></f></comments>
		<contains public="1"><f a="value">
	<d/>
	<e path="Bool"/>
</f></contains>
		<copy public="1"><f a=""><c path="flash.xml.XML"/></f></copy>
		<descendants public="1"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></descendants>
		<elements public="1"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></elements>
		<hasComplexContent public="1"><f a=""><e path="Bool"/></f></hasComplexContent>
		<hasSimpleContent public="1"><f a=""><e path="Bool"/></f></hasSimpleContent>
		<inScopeNamespaces public="1"><f a=""><c path="Array"><d/></c></f></inScopeNamespaces>
		<insertChildAfter public="1"><f a="child1:child2">
	<d/>
	<d/>
	<e path="Void"/>
</f></insertChildAfter>
		<insertChildBefore public="1"><f a="child1:child2">
	<d/>
	<d/>
	<e path="Void"/>
</f></insertChildBefore>
		<length public="1"><f a=""><c path="Int"/></f></length>
		<localName public="1"><f a=""><d/></f></localName>
		<name public="1"><f a=""><d/></f></name>
		<namespace public="1"><f a="?prefix">
	<d/>
	<e path="Void"/>
</f></namespace>
		<namespaceDeclarations public="1"><f a=""><c path="Array"><d/></c></f></namespaceDeclarations>
		<nodeKind public="1"><f a=""><c path="String"/></f></nodeKind>
		<normalize public="1"><f a=""><c path="flash.xml.XML"/></f></normalize>
		<notification public="1"><f a=""><d/></f></notification>
		<parent public="1"><f a=""><c path="flash.xml.XML"/></f></parent>
		<prependChild public="1"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></prependChild>
		<processingInstructions public="1"><f a="?name">
	<c path="String"/>
	<c path="flash.xml.XMLList"/>
</f></processingInstructions>
		<removeNamespace public="1"><f a="ns">
	<d/>
	<c path="flash.xml.XML"/>
</f></removeNamespace>
		<replace public="1"><f a="propertyName:value">
	<d/>
	<d/>
	<c path="flash.xml.XML"/>
</f></replace>
		<setChildren public="1"><f a="value">
	<d/>
	<c path="flash.xml.XML"/>
</f></setChildren>
		<setLocalName public="1"><f a="name">
	<d/>
	<e path="Void"/>
</f></setLocalName>
		<setName public="1"><f a="name">
	<d/>
	<e path="Void"/>
</f></setName>
		<setNamespace public="1"><f a="ns">
	<d/>
	<e path="Void"/>
</f></setNamespace>
		<setNotification public="1"><f a="f">
	<d/>
	<e path="Void"/>
</f></setNotification>
		<text public="1"><f a=""><c path="flash.xml.XMLList"/></f></text>
		<toString public="1"><f a=""><c path="String"/></f></toString>
		<toXMLString public="1"><f a=""><c path="String"/></f></toXMLString>
		<valueOf public="1"><f a=""><c path="flash.xml.XML"/></f></valueOf>
		<new public="1"><f a="?value">
	<d/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><c path="flash.xml.XMLList"/></haxe_dynamic>
	</class>
	<enum path="haxe.io.Error" params="" file="/usr/lib/haxe/std/haxe/io/Error.hx">
		<Overflow><haxe_doc> An integer value is outside its allowed range </haxe_doc></Overflow>
		<OutsideBounds><haxe_doc> An operation on Bytes is outside of its valid range </haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc> Other errors </haxe_doc>
		</Custom>
		<Blocked><haxe_doc> The IO is set into nonblocking mode and some data cannot be read or written </haxe_doc></Blocked>
		<haxe_doc>
	The possible IO errors that can occur
</haxe_doc>
	</enum>
	<typedef path="haxe.TypeResolver" params="" file="/usr/lib/haxe/std/haxe/Unserializer.hx" module="haxe.Unserializer"><a>
	<resolveEnum><f a="name">
	<c path="String"/>
	<c path="Enum"/>
</f></resolveEnum>
	<resolveClass><f a="name">
	<c path="String"/>
	<c path="Class"><d/></c>
</f></resolveClass>
</a></typedef>
	<enum path="haxegui.Cursor" params="" file="./haxegui/CursorManager.hx" module="haxegui.CursorManager">
		<SIZE_ALL/>
		<NW/>
		<NE/>
		<IBEAM/>
		<HAND2/>
		<HAND/>
		<DRAG/>
		<CROSSHAIR/>
		<ARROW/>
	</enum>
	<class path="haxegui.CursorManager" params="" file="./haxegui/CursorManager.hx">
		<extends path="flash.events.EventDispatcher"/>
		<_instance line="70" static="1"><c path="haxegui.CursorManager"/></_instance>
		<getInstance public="1" line="77" static="1"><f a=""><c path="haxegui.CursorManager"/></f></getInstance>
		<load_arrow line="241" static="1"><c path="flash.display.MovieClip"/></load_arrow>
		<load_hand line="242" static="1"><c path="flash.display.MovieClip"/></load_hand>
		<load_hand2 line="243" static="1"><c path="flash.display.MovieClip"/></load_hand2>
		<load_drag line="244" static="1"><c path="flash.display.MovieClip"/></load_drag>
		<load_ne line="245" static="1"><c path="flash.display.MovieClip"/></load_ne>
		<load_nw line="246" static="1"><c path="flash.display.MovieClip"/></load_nw>
		<load_sizeall line="247" static="1"><c path="flash.display.MovieClip"/></load_sizeall>
		<load_crosshair line="248" static="1"><c path="flash.display.MovieClip"/></load_crosshair>
		<listeners public="1"><c path="Array"><c path="haxegui.ITraceListener"/></c></listeners>
		<_cursor public="1"><e path="haxegui.Cursor"/></_cursor>
		<_mc public="1"><c path="flash.display.MovieClip"/></_mc>
		<init public="1" line="103">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
 * 
 * 
 * 
 </haxe_doc>
		</init>
		<getCursor public="1" line="113"><f a=""><c path="flash.display.MovieClip"/></f></getCursor>
		<inject public="1" line="119"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></inject>
		<toTop public="1" line="153"><f a=""><e path="Void"/></f></toTop>
		<setCursor public="1" line="165">
			<f a="c">
				<e path="haxegui.Cursor"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
     * 
     * 
     * 
     </haxe_doc>
		</setCursor>
		<hideCursor public="1" line="221"><f a=""><e path="Void"/></f></hideCursor>
		<showCursor public="1" line="226"><f a=""><e path="Void"/></f></showCursor>
		<visible public="1" line="231"><f a=""><e path="Bool"/></f></visible>
		<new line="88"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * 
 * Cursor Manager Class (Singleton)
 * 
 * 
 * 
 * 
 </haxe_doc>
	</class>
	<class path="flash.system.IME" params="" file="/usr/lib/haxe/std/flash9/system/IME.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<constructOK public="1" get="null" static="1"><e path="Void"/></constructOK>
		<conversionMode public="1" static="1"><e path="flash.system.IMEConversionMode"/></conversionMode>
		<enabled public="1" static="1"><e path="Bool"/></enabled>
		<doConversion public="1" static="1"><f a=""><e path="Void"/></f></doConversion>
		<setCompositionString public="1" static="1"><f a="composition">
	<c path="String"/>
	<e path="Void"/>
</f></setCompositionString>
	</class>
	<class path="flash.net.URLRequest" params="" file="/usr/lib/haxe/std/flash9/net/URLRequest.hx" extern="1">
		<contentType public="1"><c path="String"/></contentType>
		<data public="1"><d/></data>
		<digest public="1">
			<c path="String"/>
			<haxe_doc> added in FP 9.0.115 </haxe_doc>
		</digest>
		<method public="1"><c path="String"/></method>
		<requestHeaders public="1"><c path="Array"><c path="flash.net.URLRequestHeader"/></c></requestHeaders>
		<url public="1"><c path="String"/></url>
		<new public="1"><f a="?url">
	<c path="String"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="flash.text.TextField" params="" file="/usr/lib/haxe/std/flash9/text/TextField.hx" extern="1">
		<extends path="flash.display.InteractiveObject"/>
		<alwaysShowSelection public="1"><e path="Bool"/></alwaysShowSelection>
		<antiAliasType public="1"><e path="flash.text.AntiAliasType"/></antiAliasType>
		<autoSize public="1"><e path="flash.text.TextFieldAutoSize"/></autoSize>
		<background public="1"><e path="Bool"/></background>
		<backgroundColor public="1"><t path="UInt"/></backgroundColor>
		<border public="1"><e path="Bool"/></border>
		<borderColor public="1"><t path="UInt"/></borderColor>
		<bottomScrollV public="1" set="null"><c path="Int"/></bottomScrollV>
		<caretIndex public="1" set="null"><c path="Int"/></caretIndex>
		<condenseWhite public="1"><e path="Bool"/></condenseWhite>
		<defaultTextFormat public="1"><c path="flash.text.TextFormat"/></defaultTextFormat>
		<displayAsPassword public="1"><e path="Bool"/></displayAsPassword>
		<embedFonts public="1"><e path="Bool"/></embedFonts>
		<gridFitType public="1"><e path="flash.text.GridFitType"/></gridFitType>
		<htmlText public="1"><c path="String"/></htmlText>
		<length public="1" set="null"><c path="Int"/></length>
		<maxChars public="1"><c path="Int"/></maxChars>
		<maxScrollH public="1" set="null"><c path="Int"/></maxScrollH>
		<maxScrollV public="1" set="null"><c path="Int"/></maxScrollV>
		<mouseWheelEnabled public="1"><e path="Bool"/></mouseWheelEnabled>
		<multiline public="1"><e path="Bool"/></multiline>
		<numLines public="1" set="null"><c path="Int"/></numLines>
		<restrict public="1"><c path="String"/></restrict>
		<scrollH public="1"><c path="Int"/></scrollH>
		<scrollV public="1"><c path="Int"/></scrollV>
		<selectable public="1"><e path="Bool"/></selectable>
		<selectedText public="1" set="null"><c path="String"/></selectedText>
		<selectionBeginIndex public="1" set="null"><c path="Int"/></selectionBeginIndex>
		<selectionEndIndex public="1" set="null"><c path="Int"/></selectionEndIndex>
		<sharpness public="1"><c path="Float"/></sharpness>
		<styleSheet public="1"><c path="flash.text.StyleSheet"/></styleSheet>
		<text public="1"><c path="String"/></text>
		<textColor public="1"><t path="UInt"/></textColor>
		<textHeight public="1" set="null"><c path="Float"/></textHeight>
		<textWidth public="1" set="null"><c path="Float"/></textWidth>
		<thickness public="1"><c path="Float"/></thickness>
		<type public="1"><e path="flash.text.TextFieldType"/></type>
		<useRichTextClipboard public="1"><e path="Bool"/></useRichTextClipboard>
		<wordWrap public="1"><e path="Bool"/></wordWrap>
		<appendText public="1"><f a="newText">
	<c path="String"/>
	<e path="Void"/>
</f></appendText>
		<getCharBoundaries public="1"><f a="charIndex">
	<c path="Int"/>
	<c path="flash.geom.Rectangle"/>
</f></getCharBoundaries>
		<getCharIndexAtPoint public="1"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getCharIndexAtPoint>
		<getFirstCharInParagraph public="1"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getFirstCharInParagraph>
		<getImageReference public="1"><f a="id">
	<c path="String"/>
	<c path="flash.display.DisplayObject"/>
</f></getImageReference>
		<getLineIndexAtPoint public="1"><f a="x:y">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Int"/>
</f></getLineIndexAtPoint>
		<getLineIndexOfChar public="1"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineIndexOfChar>
		<getLineLength public="1"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineLength>
		<getLineMetrics public="1"><f a="lineIndex">
	<c path="Int"/>
	<c path="flash.text.TextLineMetrics"/>
</f></getLineMetrics>
		<getLineOffset public="1"><f a="lineIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getLineOffset>
		<getLineText public="1"><f a="lineIndex">
	<c path="Int"/>
	<c path="String"/>
</f></getLineText>
		<getParagraphLength public="1"><f a="charIndex">
	<c path="Int"/>
	<c path="Int"/>
</f></getParagraphLength>
		<getRawText public="1"><f a=""><c path="String"/></f></getRawText>
		<getTextFormat public="1"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="flash.text.TextFormat"/>
</f></getTextFormat>
		<getTextRuns public="1"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="Array"><d/></c>
</f></getTextRuns>
		<getXMLText public="1"><f a="?beginIndex:?endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
</f></getXMLText>
		<insertXMLText public="1"><f a="beginIndex:endIndex:richText:?pasting">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Bool"/>
	<e path="Void"/>
</f></insertXMLText>
		<replaceSelectedText public="1"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></replaceSelectedText>
		<replaceText public="1"><f a="beginIndex:endIndex:newText">
	<c path="Int"/>
	<c path="Int"/>
	<c path="String"/>
	<e path="Void"/>
</f></replaceText>
		<setSelection public="1"><f a="beginIndex:endIndex">
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setSelection>
		<setTextFormat public="1"><f a="format:?beginIndex:?endIndex">
	<c path="flash.text.TextFormat"/>
	<c path="Int"/>
	<c path="Int"/>
	<e path="Void"/>
</f></setTextFormat>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="App" params="" file="./App.hx">
		<extends path="flash.display.Sprite"/>
		<implements path="haxe.rtti.Infos"/>
		<__rtti public="1" line="101" static="1"><c path="String"/></__rtti>
		<log static="1"><c path="haxe.Log"/></log>
		<main public="1" line="106" static="1"><f a=""><e path="Void"/></f></main>
		<loadXML public="1" line="415" static="1">
			<f a="e">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	</haxe_doc>
		</loadXML>
		<tweenWindows public="1" line="438" static="1">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	 * 
	 * 
	 </haxe_doc>
		</tweenWindows>
		<setRedirection public="1" line="460" static="1">
			<f a="f">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</setRedirection>
		<onStageResize public="1" line="469" static="1">
			<f a="e">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onStageResize>
		<new public="1" line="101"><f a=""><e path="Void"/></f></new>
	</class>
	<typedef path="feffects.Easing" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/Tween.hx" module="feffects.Tween"><f a=":::">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></typedef>
	<class path="feffects.Tween" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/Tween.hx">
		<aTweens line="31" static="1"><c path="haxe.FastList_feffects_Tween"/></aTweens>
		<aPaused line="32" static="1"><c path="haxe.FastList_feffects_Tween"/></aPaused>
		<jsDate line="33" static="1"><c path="Float"/></jsDate>
		<interval line="34" static="1"><c path="Int"/></interval>
		<timer static="1"><c path="haxe.Timer"/></timer>
		<AddTween line="55" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></AddTween>
		<RemoveTween line="61" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></RemoveTween>
		<getActiveTweens public="1" line="75" static="1"><f a=""><c path="haxe.FastList_feffects_Tween"/></f></getActiveTweens>
		<getPausedTweens public="1" line="80" static="1"><f a=""><c path="haxe.FastList_feffects_Tween"/></f></getPausedTweens>
		<setTweenPaused line="85" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></setTweenPaused>
		<setTweenActive line="94" static="1"><f a="tween">
	<c path="feffects.Tween"/>
	<e path="Void"/>
</f></setTweenActive>
		<DispatchTweens line="103" static="1"><f a=""><e path="Void"/></f></DispatchTweens>
		<duration public="1" set="null"><c path="Int"/></duration>
		<position public="1" set="null"><c path="Int"/></position>
		<reversed public="1" set="null"><e path="Bool"/></reversed>
		<isPlaying public="1" set="null"><e path="Bool"/></isPlaying>
		<initVal><c path="Float"/></initVal>
		<endVal><c path="Float"/></endVal>
		<startTime><c path="Int"/></startTime>
		<pauseTime><c path="Int"/></pauseTime>
		<offsetTime><c path="Int"/></offsetTime>
		<reverseTime><c path="Int"/></reverseTime>
		<updateFunc><f a="">
	<c path="Float"/>
	<e path="Void"/>
</f></updateFunc>
		<endFunc><f a="">
	<c path="Float"/>
	<e path="Void"/>
</f></endFunc>
		<easingF><t path="feffects.Easing"/></easingF>
		<obj><d/></obj>
		<prop><c path="String"/></prop>
		<start public="1" line="131"><f a=""><e path="Void"/></f></start>
		<pause public="1" line="152"><f a=""><e path="Void"/></f></pause>
		<resume public="1" line="163"><f a=""><e path="Void"/></f></resume>
		<seek public="1" line="179">
			<f a="ms">
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	* Go to the specified position [ms] (in ms) 
	</haxe_doc>
		</seek>
		<reverse public="1" line="187">
			<f a=""><e path="Void"/></f>
			<haxe_doc>
	* Reverse the tweeen from the current position 
	</haxe_doc>
		</reverse>
		<stop public="1" line="201"><f a=""><e path="Void"/></f></stop>
		<doInterval line="207"><f a=""><e path="Void"/></f></doInterval>
		<getCurVal line="236"><f a="curTime">
	<c path="Int"/>
	<c path="Float"/>
</f></getCurVal>
		<endTween line="241"><f a=""><e path="Void"/></f></endTween>
		<setTweenHandlers public="1" line="264">
			<f a="update:?end">
				<f a="">
					<c path="Float"/>
					<e path="Void"/>
				</f>
				<f a="">
					<c path="Float"/>
					<e path="Void"/>
				</f>
				<e path="Void"/>
			</f>
			<haxe_doc>
	* Set the [update] event when the value is tweening, and the [end] value when it finished
	</haxe_doc>
		</setTweenHandlers>
		<setEasing public="1" line="273">
			<f a="easingFunc">
				<t path="feffects.Easing"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	* Set the [easingFunc] equation to use for tweening
	</haxe_doc>
		</setEasing>
		<easingEquation line="279"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easingEquation>
		<new public="1" line="115">
			<f a="init:end:dur:?obj:?prop:?easing">
				<c path="Float"/>
				<c path="Float"/>
				<c path="Int"/>
				<d/>
				<c path="String"/>
				<t path="feffects.Easing"/>
				<e path="Void"/>
			</f>
			<haxe_doc><![CDATA[
	* Create a tween from the [init] value, to the [end] value, while [dur] (in ms)<br />
	* If [obj] & [prop] set, Reflect is used to apply the value to the obj's param
	* There is a default easing equation.
	]]></haxe_doc>
		</new>
		<haxe_doc><![CDATA[
* Class that allows tweening numerical values of an object.<br/>
* Version 1.1.2
* Usage :<br/>
* import feffects.Tween;<br/>
* import feffects.easing.Elastic;<br/>
* ...<br/>
* var t = new Tween( 0, 100, 2000, mySprite, "y", Elastic.easeIn );	// create a new tween with object and property set<br/>
* OR
* var t = new Tween( 0, 100, 2000, Elastic.easeIn );				// create a new tween<br/>
* t.setTweenHandlers( update, end );								// (optional if object and property specified) set the callback functions<br/>
* AND
* t.start();														// start the tween<br/>
* 
* t.setEasing( Elastic.easeIn );									// (optional) set the easing function used to compute values<br/>
* t.seek( 1000 );													// (optional) go to the specified position (in ms)</br>
* t.pause();<br/>
* t.resume();<br/>
* t.reverse();														// reverse the tween from the current position</br>
* t.stop();
]]></haxe_doc>
	</class>
	<class path="haxegui.MouseManager" params="" file="./haxegui/MouseManager.hx">
		<extends path="flash.events.EventDispatcher"/>
		<_instance line="60" static="1"><c path="haxegui.MouseManager"/></_instance>
		<getInstance public="1" line="65" static="1"><f a=""><c path="haxegui.MouseManager"/></f></getInstance>
		<listeners public="1"><c path="Array"><c path="haxegui.ITraceListener"/></c></listeners>
		<init public="1" line="87"><f a=""><e path="Void"/></f></init>
		<onMouseEnter public="1" line="102"><f a="e">
	<c path="flash.events.MouseEvent"/>
	<e path="Void"/>
</f></onMouseEnter>
		<onMouseLeave public="1" line="111"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onMouseLeave>
		<new line="76"><f a=""><e path="Void"/></f></new>
		<haxe_doc>
 * 
 * Mouse Manager Class (Singleton)
 * 
 * Injects mouse position to fake cursor, leaving the real one free to drag.
 * 
 * 
 </haxe_doc>
	</class>
	<enum path="flash.display.StageScaleMode" params="" file="/usr/lib/haxe/std/flash9/display/StageScaleMode.hx">
		<SHOW_ALL/>
		<NO_SCALE/>
		<NO_BORDER/>
		<EXACT_FIT/>
	</enum>
	<class path="feffects.easing.Quart" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Quart.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" line="5" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" line="10" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" line="15" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="haxegui.FocusManager" params="" file="./haxegui/FocusManager.hx">
		<extends path="flash.events.EventDispatcher"/>
		<_instance line="40" static="1"><c path="haxegui.FocusManager"/></_instance>
		<_focus static="1"><c path="flash.display.DisplayObject"/></_focus>
		<_oldFocus static="1"><c path="flash.display.DisplayObject"/></_oldFocus>
		<_showFocus static="1"><e path="Bool"/></_showFocus>
		<getInstance public="1" line="49" static="1"><f a=""><c path="haxegui.FocusManager"/></f></getInstance>
		<setFocus public="1" line="74"><f a="o">
	<c path="flash.display.DisplayObject"/>
	<e path="Void"/>
</f></setFocus>
		<getFocus public="1" line="99"><f a=""><c path="flash.display.DisplayObject"/></f></getFocus>
		<onFocusChanged public="1" line="104"><f a="e">
	<c path="flash.events.FocusEvent"/>
	<e path="Void"/>
</f></onFocusChanged>
		<new public="1" line="60"><f a=""><e path="Void"/></f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.text.GridFitType" params="" file="/usr/lib/haxe/std/flash9/text/GridFitType.hx">
		<SUBPIXEL/>
		<PIXEL/>
		<NONE/>
	</enum>
	<class path="feffects.easing.Quint" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Quint.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" line="5" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" line="10" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" line="15" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="haxegui.controls.ComboBox" params="" file="./haxegui/controls/ComboBox.hx">
		<extends path="haxegui.controls.Button"/>
		<back public="1"><c path="flash.display.Sprite"/></back>
		<dropButton public="1"><c path="haxegui.controls.Button"/></dropButton>
		<tf public="1"><c path="flash.text.TextField"/></tf>
		<onEnabled public="1" line="140"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onEnabled>
		<onDisabled public="1" line="144"><f a="e">
	<c path="flash.events.Event"/>
	<e path="Void"/>
</f></onDisabled>
		<redrawButton public="1" line="152">
			<f a="?color">
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	</haxe_doc>
		</redrawButton>
		<new public="1" line="61"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_doc>
 * 
 * 
 * 
 * 
 </haxe_doc>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="flash.display.BlendMode" params="" file="/usr/lib/haxe/std/flash9/display/BlendMode.hx">
		<SUBTRACT/>
		<SCREEN/>
		<OVERLAY/>
		<NORMAL/>
		<MULTIPLY/>
		<LIGHTEN/>
		<LAYER/>
		<INVERT/>
		<HARDLIGHT/>
		<ERASE/>
		<DIFFERENCE/>
		<DARKEN/>
		<ALPHA/>
		<ADD/>
	</enum>
	<class path="feffects.easing.Sine" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Sine.hx">
		<implements path="haxe.Public"/>
		<easeIn public="1" line="5" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" line="10" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" line="15" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="flash.utils.ByteArray" params="" file="/usr/lib/haxe/std/flash9/utils/ByteArray.hx" extern="1">
		<implements path="flash.utils.IDataOutput"/>
		<implements path="flash.utils.IDataInput"/>
		<defaultObjectEncoding public="1" static="1"><t path="UInt"/></defaultObjectEncoding>
		<bytesAvailable public="1" set="null"><t path="UInt"/></bytesAvailable>
		<endian public="1"><e path="flash.utils.Endian"/></endian>
		<length public="1"><t path="UInt"/></length>
		<objectEncoding public="1"><t path="UInt"/></objectEncoding>
		<position public="1"><t path="UInt"/></position>
		<compress public="1"><f a=""><e path="Void"/></f></compress>
		<readBoolean public="1"><f a=""><e path="Bool"/></f></readBoolean>
		<readByte public="1"><f a=""><c path="Int"/></f></readByte>
		<readBytes public="1"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></readBytes>
		<readDouble public="1"><f a=""><c path="Float"/></f></readDouble>
		<readFloat public="1"><f a=""><c path="Float"/></f></readFloat>
		<readInt public="1"><f a=""><c path="Int"/></f></readInt>
		<readMultiByte public="1"><f a="length:charSet">
	<t path="UInt"/>
	<c path="String"/>
	<c path="String"/>
</f></readMultiByte>
		<readObject public="1"><f a=""><d/></f></readObject>
		<readShort public="1"><f a=""><c path="Int"/></f></readShort>
		<readUTF public="1"><f a=""><c path="String"/></f></readUTF>
		<readUTFBytes public="1"><f a="length">
	<t path="UInt"/>
	<c path="String"/>
</f></readUTFBytes>
		<readUnsignedByte public="1"><f a=""><t path="UInt"/></f></readUnsignedByte>
		<readUnsignedInt public="1"><f a=""><t path="UInt"/></f></readUnsignedInt>
		<readUnsignedShort public="1"><f a=""><t path="UInt"/></f></readUnsignedShort>
		<toString public="1"><f a=""><c path="String"/></f></toString>
		<uncompress public="1"><f a=""><e path="Void"/></f></uncompress>
		<writeBoolean public="1"><f a="value">
	<e path="Bool"/>
	<e path="Void"/>
</f></writeBoolean>
		<writeByte public="1"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeByte>
		<writeBytes public="1"><f a="bytes:?offset:?length">
	<c path="flash.utils.ByteArray"/>
	<t path="UInt"/>
	<t path="UInt"/>
	<e path="Void"/>
</f></writeBytes>
		<writeDouble public="1"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeDouble>
		<writeFloat public="1"><f a="value">
	<c path="Float"/>
	<e path="Void"/>
</f></writeFloat>
		<writeInt public="1"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeInt>
		<writeMultiByte public="1"><f a="value:charSet">
	<c path="String"/>
	<c path="String"/>
	<e path="Void"/>
</f></writeMultiByte>
		<writeObject public="1"><f a="object">
	<d/>
	<e path="Void"/>
</f></writeObject>
		<writeShort public="1"><f a="value">
	<c path="Int"/>
	<e path="Void"/>
</f></writeShort>
		<writeUTF public="1"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTF>
		<writeUTFBytes public="1"><f a="value">
	<c path="String"/>
	<e path="Void"/>
</f></writeUTFBytes>
		<writeUnsignedInt public="1"><f a="value">
	<t path="UInt"/>
	<e path="Void"/>
</f></writeUnsignedInt>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.ui.ContextMenu" params="" file="/usr/lib/haxe/std/flash9/ui/ContextMenu.hx" extern="1">
		<extends path="flash.events.EventDispatcher"/>
		<builtInItems public="1"><c path="flash.ui.ContextMenuBuiltInItems"/></builtInItems>
		<customItems public="1"><c path="Array"><d/></c></customItems>
		<clone public="1"><f a=""><c path="flash.ui.ContextMenu"/></f></clone>
		<hideBuiltInItems public="1"><f a=""><e path="Void"/></f></hideBuiltInItems>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="flash.display.Loader" params="" file="/usr/lib/haxe/std/flash9/display/Loader.hx" extern="1">
		<extends path="flash.display.DisplayObjectContainer"/>
		<content public="1" set="null"><c path="flash.display.DisplayObject"/></content>
		<contentLoaderInfo public="1" set="null"><c path="flash.display.LoaderInfo"/></contentLoaderInfo>
		<close public="1"><f a=""><e path="Void"/></f></close>
		<load public="1"><f a="request:?context">
	<c path="flash.net.URLRequest"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></load>
		<loadBytes public="1"><f a="bytes:?context">
	<c path="flash.utils.ByteArray"/>
	<c path="flash.system.LoaderContext"/>
	<e path="Void"/>
</f></loadBytes>
		<unload public="1"><f a=""><e path="Void"/></f></unload>
		<new public="1"><f a=""><e path="Void"/></f></new>
	</class>
	<class path="feffects.easing.Bounce" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Bounce.hx">
		<implements path="haxe.Public"/>
		<easeOut public="1" line="5" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeIn public="1" line="17" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeInOut public="1" line="22" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="DateTools" params="" file="/usr/lib/haxe/std/DateTools.hx">
		<__format_get line="38" static="1"><f a="d:e">
	<c path="Date"/>
	<c path="String"/>
	<c path="String"/>
</f></__format_get>
		<__format line="91" static="1"><f a="d:f">
	<c path="Date"/>
	<c path="String"/>
	<c path="String"/>
</f></__format>
		<format public="1" line="116" static="1">
			<f a="d:f">
				<c path="Date"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Format the date [d] according to the format [f]. The format
		is compatible with the [strftime] standard format, except that there
		is no support in Flash and JS for day and months names (due to lack
		of proper internationalization API). On haXe/Neko/Windows, some
		formats are not supported.
	</haxe_doc>
		</format>
		<delta public="1" line="129" static="1">
			<f a="d:t">
				<c path="Date"/>
				<c path="Float"/>
				<c path="Date"/>
			</f>
			<haxe_doc>
		Returns a Date which time has been changed by [t] milliseconds.
	</haxe_doc>
		</delta>
		<DAYS_OF_MONTH line="133" static="1"><c path="Array"><c path="Int"/></c></DAYS_OF_MONTH>
		<getMonthDays public="1" line="138" static="1">
			<f a="d">
				<c path="Date"/>
				<c path="Int"/>
			</f>
			<haxe_doc>
		Returns the number of days in a month
	</haxe_doc>
		</getMonthDays>
		<seconds public="1" line="152" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of seconds to a date-time
	</haxe_doc>
		</seconds>
		<minutes public="1" line="159" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of minutes to a date-time
	</haxe_doc>
		</minutes>
		<hours public="1" line="166" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of hours to a date-time
	</haxe_doc>
		</hours>
		<days public="1" line="173" static="1">
			<f a="n">
				<c path="Float"/>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Convert a number of days to a date-time
	</haxe_doc>
		</days>
		<parse public="1" line="180" static="1">
			<f a="t">
				<c path="Float"/>
				<a>
					<seconds><c path="Int"/></seconds>
					<ms><c path="Float"/></ms>
					<minutes><c path="Int"/></minutes>
					<hours><c path="Int"/></hours>
					<days><c path="Int"/></days>
				</a>
			</f>
			<haxe_doc>
		Separate a date-time into several components
	</haxe_doc>
		</parse>
		<make public="1" line="196" static="1">
			<f a="o">
				<a>
					<seconds><c path="Int"/></seconds>
					<ms><c path="Float"/></ms>
					<minutes><c path="Int"/></minutes>
					<hours><c path="Int"/></hours>
					<days><c path="Int"/></days>
				</a>
				<c path="Float"/>
			</f>
			<haxe_doc>
		Build a date-time from several components
	</haxe_doc>
		</make>
		<haxe_doc>
	The DateTools class contains some extra functionalities for [Date]
	manipulation. It's stored in a different class in order to prevent
	the standard [Date] of being bloated and thus increasing the size of
	each application using it.
</haxe_doc>
	</class>
	<class path="haxegui.DragManager" params="" file="./haxegui/DragManager.hx">
		<extends path="flash.events.EventDispatcher"/>
		<_instance line="38" static="1"><c path="haxegui.DragManager"/></_instance>
		<getInstance public="1" line="43" static="1"><f a=""><c path="haxegui.DragManager"/></f></getInstance>
		<listeners public="1"><c path="Array"><c path="haxegui.ITraceListener"/></c></listeners>
		<onStartDrag public="1" line="65"><f a="e">
	<c path="haxegui.events.DragEvent"/>
	<e path="Void"/>
</f></onStartDrag>
		<onStopDrag public="1" line="73"><f a="e">
	<c path="haxegui.events.DragEvent"/>
	<e path="Void"/>
</f></onStopDrag>
		<new public="1" line="54"><f a=""><e path="Void"/></f></new>
	</class>
	<enum path="flash.display.StageQuality" params="" file="/usr/lib/haxe/std/flash9/display/StageQuality.hx">
		<MEDIUM/>
		<LOW/>
		<HIGH/>
		<BEST/>
	</enum>
	<enum path="flash.display.JointStyle" params="" file="/usr/lib/haxe/std/flash9/display/JointStyle.hx">
		<ROUND/>
		<MITER/>
		<BEVEL/>
	</enum>
	<class path="haxegui.controls.RadioButton" params="" file="./haxegui/controls/RadioButton.hx">
		<extends path="haxegui.controls.Component"/>
		<checked public="1"><e path="Bool"/></checked>
		<label public="1"><c path="haxegui.controls.Label"/></label>
		<color public="1"><t path="UInt"/></color>
		<button><c path="flash.display.Sprite"/></button>
		<init public="1" line="74">
			<f a="?initObj">
				<d/>
				<e path="Void"/>
			</f>
			<haxe_doc>
   * 
   * 
   * 
   * 
   </haxe_doc>
		</init>
		<onDisabled public="1" line="149">
			<f a="e">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 </haxe_doc>
		</onDisabled>
		<onEnabled public="1" line="161">
			<f a="e">
				<c path="flash.events.Event"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 * 
	 * 
	 </haxe_doc>
		</onEnabled>
		<redraw public="1" line="174">
			<f a="?color">
				<t path="UInt"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	 *
	 </haxe_doc>
		</redraw>
		<onRollOver public="1" line="208">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onRollOver>
		<onRollOut public="1" line="223">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onRollOut>
		<onMouseDown public="1" line="234">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onMouseDown>
		<onMouseUp public="1" line="264">
			<f a="e">
				<c path="flash.events.MouseEvent"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
	*
	*
	</haxe_doc>
		</onMouseUp>
		<new public="1" line="62"><f a="?parent:?name:?x:?y">
	<c path="flash.display.DisplayObjectContainer"/>
	<c path="String"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
		<haxe_dynamic><d/></haxe_dynamic>
	</class>
	<enum path="XmlType" params="" file="/usr/lib/haxe/std/Xml.hx" module="Xml"><haxe_doc>
	An abstract type representing the type of the Xml
	Node. You can compare it to [Xml] statics and can
	use [Std.string(t)] to get a string reprensation
	of the type.
</haxe_doc></enum>
	<class path="Xml" params="" file="/usr/lib/haxe/std/Xml.hx" extern="1">
		<Element public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Element>
		<PCData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</PCData>
		<CData public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</CData>
		<Comment public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Comment>
		<DocType public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</DocType>
		<Prolog public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Prolog>
		<Document public="1" set="null" static="1">
			<e path="XmlType"/>
			<haxe_doc>
		A type of Xml node.
	</haxe_doc>
		</Document>
		<parse public="1" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Parse a String into an Xml object.
	</haxe_doc>
		</parse>
		<createElement public="1" static="1">
			<f a="name">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createElement>
		<createPCData public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createPCData>
		<createCData public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createCData>
		<createComment public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createComment>
		<createDocType public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocType>
		<createProlog public="1" static="1">
			<f a="data">
				<c path="String"/>
				<c path="Xml"/>
			</f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createProlog>
		<createDocument public="1" static="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Creates a node of the given type.
	</haxe_doc>
		</createDocument>
		<nodeType public="1" set="null">
			<e path="XmlType"/>
			<haxe_doc>
		Returns the type of the Xml Node. This should be used before
		accessing other functions since some might raise an exception
		if the node type is not correct.
	</haxe_doc>
		</nodeType>
		<nodeName public="1" get="getNodeName" set="setNodeName">
			<c path="String"/>
			<haxe_doc>
		Returns the node name of an Element.
	</haxe_doc>
		</nodeName>
		<getNodeName><f a=""><c path="String"/></f></getNodeName>
		<setNodeName><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeName>
		<nodeValue public="1" get="getNodeValue" set="setNodeValue">
			<c path="String"/>
			<haxe_doc>
		Returns the node value. Only works if the Xml node is not an Element or a Document.
	</haxe_doc>
		</nodeValue>
		<getNodeValue><f a=""><c path="String"/></f></getNodeValue>
		<setNodeValue><f a="name">
	<c path="String"/>
	<c path="String"/>
</f></setNodeValue>
		<get public="1">
			<f a="att">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>
		Get the given attribute of an Element node. Returns [null] if not found.
		Attributes are case-sensitive.
	</haxe_doc>
		</get>
		<set public="1">
			<f a="att:value">
				<c path="String"/>
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Set the given attribute value for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</set>
		<remove public="1">
			<f a="att">
				<c path="String"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Removes an attribute for an Element node.
		Attributes are case-sensitive.
	</haxe_doc>
		</remove>
		<exists public="1">
			<f a="att">
				<c path="String"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Tells if the Element node has a given attribute.
		Attributes are case-sensitive.
	</haxe_doc>
		</exists>
		<attributes public="1">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>
		Returns an [Iterator] on all the attributes values.
	</haxe_doc>
		</attributes>
		<parent public="1" get="getParent" set="null">
			<c path="Xml"/>
			<haxe_doc>
		Returns the parent object in the Xml hierarchy.
		The parent can be [null], an Element or a Document.
	</haxe_doc>
		</parent>
		<getParent><f a=""><c path="Xml"/></f></getParent>
		<iterator public="1">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</iterator>
		<elements public="1">
			<f a=""><t path="Iterator"><c path="Xml"/></t></f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elements>
		<elementsNamed public="1">
			<f a="name">
				<c path="String"/>
				<t path="Iterator"><c path="Xml"/></t>
			</f>
			<haxe_doc>
		Returns an iterator of all child nodes which are Elements with the given nodeName.
		Only works if the current node is an Element or a Document.
	</haxe_doc>
		</elementsNamed>
		<firstChild public="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node.
	</haxe_doc>
		</firstChild>
		<firstElement public="1">
			<f a=""><c path="Xml"/></f>
			<haxe_doc>
		Returns the first child node which is an Element.
	</haxe_doc>
		</firstElement>
		<addChild public="1">
			<f a="x">
				<c path="Xml"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Adds a child node to the Document or Element.
		One node can only be inside one given node which is indicated by the [parent] property.
	</haxe_doc>
		</addChild>
		<removeChild public="1">
			<f a="x">
				<c path="Xml"/>
				<e path="Bool"/>
			</f>
			<haxe_doc>
		Removes a child from the Document or Element.
		Returns true if the child was successfuly removed.
	</haxe_doc>
		</removeChild>
		<insertChild public="1">
			<f a="x:pos">
				<c path="Xml"/>
				<c path="Int"/>
				<e path="Void"/>
			</f>
			<haxe_doc>
		Inserts a child at the given position among the other childs.
	</haxe_doc>
		</insertChild>
		<toString public="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>
		Returns a String representation of the Xml node.
	</haxe_doc>
		</toString>
		<haxe_doc>
	The standard Xml class and parsing.
	More API to manipulate XML are available in the [haxe.xml] package.
</haxe_doc>
	</class>
	<class path="feffects.easing.Linear" params="" file="/home/gershon/haxelib/feffects/1,1,2/feffects/easing/Linear.hx">
		<implements path="haxe.Public"/>
		<easeNone public="1" line="5" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeNone>
		<easeIn public="1" line="10" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeIn>
		<easeOut public="1" line="15" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeOut>
		<easeInOut public="1" line="20" static="1"><f a="t:b:c:d">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
</f></easeInOut>
	</class>
	<class path="flash.geom.ColorTransform" params="" file="/usr/lib/haxe/std/flash9/geom/ColorTransform.hx" extern="1">
		<alphaMultiplier public="1"><c path="Float"/></alphaMultiplier>
		<alphaOffset public="1"><c path="Float"/></alphaOffset>
		<blueMultiplier public="1"><c path="Float"/></blueMultiplier>
		<blueOffset public="1"><c path="Float"/></blueOffset>
		<color public="1"><t path="UInt"/></color>
		<greenMultiplier public="1"><c path="Float"/></greenMultiplier>
		<greenOffset public="1"><c path="Float"/></greenOffset>
		<redMultiplier public="1"><c path="Float"/></redMultiplier>
		<redOffset public="1"><c path="Float"/></redOffset>
		<concat public="1"><f a="second">
	<c path="flash.geom.ColorTransform"/>
	<e path="Void"/>
</f></concat>
		<toString public="1"><f a=""><c path="String"/></f></toString>
		<new public="1"><f a="?redMultiplier:?greenMultiplier:?blueMultiplier:?alphaMultiplier:?redOffset:?greenOffset:?blueOffset:?alphaOffset">
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<c path="Float"/>
	<e path="Void"/>
</f></new>
	</class>
	<class path="@Main" params="" file=""><init line="1" static="1"><e path="Void"/></init></class>
</haxe>